<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />


    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
   
   
  	<link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

	<title>Sprint1 Thomas Ambrogini</title>
		
</head>
    
<body>
	<div id="top">
	<h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font> </h1>
	</div>  
	
	<div class="body"> 
	<h2>Introduction</h2>
	<div  class="remark">
	Tema finale dell'esame di ingegneria dei sistemi software: WasteService
	</div>
	 
	<h2>Requirements</h2>
	
	<a class="headerlink" href="./TemaFinale22.html" title="Permalink to this headline">Testo requisiti fornito dal committente</a>

	
	<h2>Requirement analysis</h2>
	
	<div class="remark">
	<section id="requisiti-funzionali">
		<h3>Requisiti funzionali<a class="headerlink" href="#requisiti-funzionali" title="Permalink to this headline">¶</a></h3>
		
		Requisiti riguardanti la funzionalità CORE del sistema
		<ol class="arabic simple">
			<li>
				<p><em>Arrivo waste truck</em>: Un waste truck si reca nella posizione indoor ed invia una richiesta per il deposito di un certo materiale (glass or plastic) e il carico che vuole depositare.</p>	
			</li>
			<li>
				<p><em>Accettato</em>: nel caso in cui il carico che si vuole depositare sommato al carico attuale dell'apposito container non ecceda una determinata soglia (PMAX or GMAX), wasteService invia la risposta loadaccepted .</p>	
			</li>
			<li>
				<p><em>Respinto</em>: nel caso in cui il carico che si vuole depositare sommato al carico attuale dell'apposito container ecceda una determinata soglia (PMAX or GMAX), wasteService invia la risposta loadrejected ed il wasteTruck libera l'area di INDOOR .</p>	
			</li>
			<li>
				<p><em>Ritiro</em>: Nel caso in cui la richiesta sia stata accettata, il trolley deve recarsi ad INDOOR per prelevare il carico dal wasteTruck. </p>
			</li>
			<li>
				<p><em>Deposito</em>: Il trolley si reca all'apposito container per depositare il carico.</p>
			</li>
			<li>
				<p><em>Fine deposito</em>: quando il trolley termina il deposito, nel caso in cui ci siano altre richieste accettate, il trolley ripete la fase RITIRO descritta precedentemente, in caso contrario torna alla posizione HOME.</p>
			</li>
		</ol>
		
		Requisiti riguardanti LED e SONAR
		<ol class="arabic simple">
			<li>
				<p><em>Led Off</em>: nel caso in cui il trolley si trovi nella posizione HOME.</p>	
			</li>
			<li>
				<p><em>Led Blinks</em>: mentre il trolley si sta muovendo.</p>	
			</li>
			<li>
				<p><em>Led On</em>: quando il trolley è stoppato.</p>	
			</li>
			<li>
				<p><em>Sonar</em>: nel caso in cui il sonar misuri una distanza minore di DLIMIT, il trolley deve essere stoppato. Verrà riattivato quando il sonar rileverà una distanza maggiore di DLIMIT </p>
			</li>
		</ol>
		
		Requisiti riguardanti GUI
		<ol class="arabic simple">
		All'interno della GUI devono essere visibili le seguenti informazioni:
			<li>
				<p><em>Trolley info</em>: stato attuale del trolley e posizione attuale.</p>	
			</li>
			<li>
				<p><em>Peso container</em>: il peso corrente di ciascun container.</p>	
			</li>
			<li>
				<p><em>Led info</em>: stato attuale del led.</p>	
			</li>
		</ol>
		
	<section id="requisiti-non-funzionali">
		<h3>Requisiti non funzionali<a class="headerlink" href="#requisiti-non-funzionali" title="Permalink to this headline">¶</a></h3>
		
		<ol class="arabic simple">
			<li>
				<p><em>Posizione iniziale</em>: il trolley parte dalla posizione HOME.</p>	
			</li>
			<li>
				<p><em>Lunghezza del trolley</em>: il trolley ha lunghezza di lato RD.</p>
			</li>
			<li>
				<p><em>Proattività</em>: il trolley deve muoversi in modo autonomo fino a compimento del lavoro.</p>	
			</li>
			<li>
				<p><em>Reattività</em>: il committente ha prospettato la possibilità che il trolley sospenda il lavoro
				in caso di allarmi; in particolare, quando il sonar rileva una distanza minore di DLIMIT</p>
			</li>
			<li>
				<p><em>Raspberry</em>: il LED ed il SONAR devono essere collegati ad un RaspberryPI</p>
			</li>
		</ol>
	
	<section id="punti-aperti">
		<h3>Punti aperti<a class="headerlink" href="#punti-aperti" title="Permalink to this headline">¶</a></h3>
		
		<ol class="arabic simple">
			<li>
				Momento nella quale incrementare il peso contenuto nei container. Potrebbe essere incrementato sia nel momento in cui
				una richiesta viene accetata (loadaccepted), sia in seguito alla fase di RITIRO specificata nei requisiti funzionali, sia in seguito alla fase di FINE DEPOSITO.
			</li>
			<li>
				Concorrenza dei truck.
			</li>
			<li>
				In seguito a loadaccepted, il truck deposita il carico e se ne va immediatamente o aspetta l'arrivo del trolley per scaricare? Nel secondo caso si ha bisogno di notificare il 
				truck quando il carico è stato preso dal trolley?
			</li>
			<li>
				Come si vuole realizzata la visualizzazione della posizione corrente del trolley?
			</li>
			<li>
				La mappa della stanza viene fornita?
			</li>
			<li>
				Le coordinate di INDOOR, e dei container sono conosciute?
			</li>
		</ol>
	
	<section id="valori-preimpostati">
		<h3> Valori preimpostati specificati nei requisiti <a class="headerlink" href="#valori-preimpostati" title="Permalink to this headline">¶</a></h3>
			<ol class="arabic simple">
				<li>
					MAXPB: Contenuto massimo del container della plastica.
				</li>
				<li>
					MAXGB: Contenuto massimo del container del vetro.
				</li>
				<li>
					DLIMIT: Distanza sotto la quale il trolley deve essere fermato.
				</li>
				<li>
					RD: Lunghezza del lato del trolley.
				</li>
			</ol>
			

	<section id="glossario">
		<h3>Glossario<a class="headerlink" href="#glossario" title="Permalink to this headline">¶</a></h3>
			
			<ol class="arabic simple">
				<li>
					WasteTruck: camion che si approccia al sistema per poter depositare i materiali.
				</li>
				<li>
					WasteService: servizio centrale che si occupa di rispondere alle richieste del WasteTruck.
				</li>
				<li>
					DDR robot: Con il termine DDR (Differential Drive Robot) robot il commitente intende il robot del progetto unibo.basicrobot22
				</li>
				<li>
					Transport Trolley: Il transport trolley non è il DDR Robot, sono due entità distinte. Il trolley potrebbe sfruttare il DDR robot per 
					eseguire i movimenti necessari.
				</li>
				<li>
					Area di servizio: zona nella quale si muove il trolley con zone particolari:
					<ul>
						<li>
							INDOOR: area dove il trolley deve andare a raccogliere il materiali per il deposito.
						</li>
						<li>
							Home: punto di partenza del trolley.
						</li>
						<li>
							PlasticBox: area in cui è presente il contenitore per la plastica.
						</li>
						<li>
							GlassBox: area in cui è presente il contenitore per il vetro.
						</li>
					</ul>
				</li>

				<li>
					Led: spia luminosa.
				</li>
				
				<li>
					Sonar: sensore per misurare la distanza.
				</li>
				
				
			</ol>
			
	<section id="qak">
	<h3> Utilizzo di attori e QAK <a class="headerlink" href="#qak" title="Permalink to this headline">¶</a></h3>
		In questo progetto vengono utilizzati attori, come entita di base, che permettono di facilitare la realizzazione
		di un sistema distribuito. Inoltre, viene utilizzato il metalinguaggio QAK, che sfrutta gli attori, per poter definire
		in maniera formale, fin dalle prime fasi del progetto, i requisiti e poter creare prototipi per interagire con il committente.
	
	
	<h3> DDR robot e Trolley </h3>
	
	Il DDR robot NON è il transport trolley. Il transport trolley USA il DDR robot per poter eseguire le proprie azioni.
	Per 
	
	
	
	<h2> Requisiti funzionalità CORE </h2>
	Come funzionalità CORE del sistema si intende tutto il comportamento che inizia con una richiesta da parte del truck
	e termina con il deposito dei materiali.
	
	<h3> Request da parte del Truck </h3>
	Il driver esegue una richiesta per poter depositare i materiali, specificando tipo e peso del carico. Il WasteService, in caso
	il peso dei materiali non superi il valore di soglia massimo, risponde con <cite> loadaccept</cite>, in caso contrario
	risponde con <cite> loadrejected</cite>.
	
	
	
	Dai requisiti si può comprendere che il WasteService sia un'entità che possa ricevere richieste e inviare risposte
	e deve possedere una propria logica di business. Per queste ragioni verrà rappresentato il WasteService come un attore.
	
	Per quanto riguarda il WasteTruck, esso è una componente esterna al sistema da realizzare. Per scopo di testing viene realizzato
	anche esso come attore o come componente esterno realizzato in python. <br>
	
	<img src="img/ReqDeposit.jpg" alt="img"> <br>
	
	<a href="./qak/WasteServiceAnalisiRequisitiRequestAmbrogini.qakt" >Modello eseguibile request</a> <br>
	
	<a href="./test/ProblemAnalysis/TestRequest.java" >Test request</a> <br>
	
	
	<h3 id="trolley_action"> Deposito da parte del trolley</h3>
	
	Il deposito si compone di tre azioni fondamentali:
	<ol class="arabic simple">
		<li>
			Pickup del carico del truck da parte del trolley in INDOOR
		</li>
		<li>
			Il trolley si muove da INDOOR al giusto container
		</li>
		<li>
			Il trolley deposita i materiali nel container
		</li>
	</ol>
	
	Per quanto riguarda le prime due azioni, esse potrebbero essere eseguite come azione atomica (un unico messaggio
	da parte del wasteService ed il trolley esegue in successione le mosse, andando a inserire logica di business
	all'interno del trolley) oppure come azioni separate, rendendo il trolley privo di logica di business.
	In seguito a discussioni con il commitente si è deciso che la seconda opzione risulti essere più appropriata.
	
	L'interazione che si ha tra il trolley e il wasteService sarà discussa nell'analisi del problema e non in quella
	dei requisiti. Il modello e il test presentati non dipendono da queste scelte e saranno, per questo motivo, molto 
	generali, con lo scopo di presentare una demo della deposit action al committente.

	<br> <br>
	
	<a href="./qak/WasteServiceAnalisiRequisitiDepositAmbrogini.qakt" >Modello non eseguibile deposit</a> <br>
	
	<a href="./qak/WasteServiceAnalisiRequisitiDepositEseguibileAmbrogini.qakt" >Modello eseguibile deposit</a> <br>
	
	
	<a href="./test/ProblemAnalysis/TestDeposit.java" >Test deposit</a> <br>
		
	
	
	<h3> Fine Deposito</h3>
	
	Quando viene terminato il deposito da parte del trolley, esso dovrà tornare ad HOME nel caso non ci siano nuove
	richieste, altrimenti dovrà tornare ad INDOOR.<br>
	La parte di test che controlla il ritorno ad HOME risulta essere eseguibile col modello definito precedentemente, mentre
	il test con richieste successive non è al momento eseguibile, verrà reso eseguibile in analisi del problema.
	<br>
	<a href="./test/ProblemAnalysis/TestEndDeposit.java" >Test fine deposito</a> <br>
	
	<h3> Aggiornamento Pesi </h3>
	Una volta eseguito il deposito dovrà essere aggiornato il contatore dei pesi. In seguito viene illustrato un test
	per verificare che tale incremento sia corretto. Il test non è ancora eseguibile.
	<br>
	<a href="./test/ProblemAnalysis/TestUpdateWeights.java" >Test aggiornamento pesi in seguito al deposito (non eseguibile)</a> <br>
	
	
	<h2> Problematiche funzionalità CORE</h2>
	In questa sezione vengono elencate tutte le problematiche che sono state trovate analizzando i requisiti, che 
	verranno discusse nell'analisi del problema.
	
	<h3> <a href="#Problematica_Ritiro">Problematica Ritiro</a></h3>
	Quando una richiesta da parte di un WasteTruck viene accettata (loadaccepted), si ha la necessità di comunicare al 
	trolley di andare a prelevare il carico dall'area INDOOR.
	
	<h3><a href="#Problematica_Ritiro_effettuato">Problematica Ritiro effettuato</a> </h3>
	Quando il trolley effettua il ritiro dei materiali dal WasteTruck deve comunicare al WasteService di avere effettuato il ritiro.
	
	<h3> <a href="#Problematica_leave_indoor">Problematica libera area indoor</a> </h3>
	In seguito ad una loadaccepted bisogna decidere quando e come comunicare al WasteTruck di liberare
	l'area di INDOOR.
	
	<h3> <a href="#Problematica_fine_deposito">Problematica Fine Deposito</a> </h3>
	Quando il trolley deposita i materiali nel container deve comunicare di aver eseguita questa operazione.
	
	<h3> <a href="#Problematica_nuovo_deposito">Problematica Nuovo Deposito</a>  </h3>
	Quando il trolley conclude il requisito FineDeposito e quindi deposita il carico nel container appropriato si ha la necessità di
	trovare un modo per poter verificare se sono arrivati nuovi WasteTruck nel frattempo.
	
	<h3> <a href="#Problematica_container">Problematica Posizione container</a></h3>
	Quale componente deve essere a conoscenza delle posizioni dei container.
	
	<h3> <a href="#Problematica_percorso">Problematica percorso trolley</a> </h3>
	Come fa il trolley a sapere il percorso da seguire partendo da una posizione iniziale per arrivare all'obiettivo.
	
	<h3> <a href="#Problematica_peso">Problematica Peso container</a> </h3>
	Quale componente possiede l'informazione del peso attuale dei container.
	
	<h3> <a href="#Problematica_mappa">Problematica Mappa della stanza</a> </h3>
	Come viene rappresentata la mappa della stanza
	
	<h3> <a href="#Problematica_rappresentazione">Problematica rappresentazione INDOOR e dei CONTAINER</a> </h3>
	Come vengono rappresentati i CONTAINER e INDOOR nella stanza.
	
	<h3> <a href="#Problematica_mappa">Problematica rappresentazione valori predefiniti</a> </h3>
	In quale modo e quale entità è a conoscenza dei valori preimpostati definiti nei requisiti.
	
	<h3> <a href="#Problematica_posizione_trolley">Problematica posizione trolley</a> </h3>
	Quale componente è a conoscenza della posizione del robot all'interno della stanza.		


	<br>
	</div>
	
	<h2>Problem analysis</h2>

	 
	 <div class="remark">
	 
		 <h3> Obiettivi </h3>
		Uno degli obiettivi che si vuole raggiungere con l'architettura è quello di lasciare la logica di business
		principalmente all'interno del WasteService e rendere il Transport trolley un semplice attuatore, in modo da
		rendere il trolley più flessibile per possibili cambiamenti o per utilizzarlo in altri tipi di applicazione.
		Le tre azioni descritte nella parte di analisi dei requisiti, per quanto riguarda il <a href="#trolley_action"> compito del trolley</a>, 
		sarebbe opportuno fossero realizzate come azioni separate, in modo da lasciare completamente la logica di business
		all'interno del wasteService, e in caso di cambiamento di tale logica non ci sarebbe da effettuare nessuna
		modifica per quanto riguarda il trolley.
	 	
	 	<h2> Funzionalità CORE specificate nell'analisi dei requisiti </h2>
	 	
	 	<h3 id="Problematica_Ritiro"> Problematica Ritiro </h3>
	 	
	 	<img src="img/CORE1Image.jpg" alt="img"> <br>
	 	
	 	Per poter garantire che le tre azioni vengano eseguite separatamente si ha la necessità di utilizzare una comunicazione
	 	di tipo request-response in modo che il wasteService sappia quando impartire il comando successivo al trolley.
	 	
	 	<br>
	 	Caratteristiche della soluzione con dispatch:
	 	
	 	<ol class="arabic simple">
	 		<li>
	 			Semplicità: Risulta più semplice come soluzione.
	 		</li>
	 		
			<li>
				Comprensibilità: Risulta più facilmente comprensibile dato che risulta essere semplicemente
				un comando inviato dal wasteService al trolley.
			</li>
	 		
	 	</ol>
	 	
	 	<h4> Architettura #2 </h4>
	 	<img src="img/CORE2Image.jpg" alt="img"> <br>
	 	
	 	In questa seconda architettura si comunica al transport trolley di andare ad INDOOR attraverso l'utilizzo di un evento.
	 	<br>
	 	Caratteristiche della soluzione ad evento:
	 	
	 	<ol class="arabic simple">
	 		<li>
	 			Flessibilità: risulta molto semplice apportare modifiche.
	 		    In particolare, nel caso fosse stato possibile avere più trolley, allora, sarebbe stato 
	 			semplice aggiungere nuovi trolley e la decisione su quale trolley attivare non sarebbe stata
	 			in carico al WasteService.
	 		</li>
	 		
	 		<li>
	 			L'informazione sarebbe percettibile da un numero qualsiasi di osservatori interessati, senza che
	 			l'azione di osservazione comporti un cambiamento del WasteService. In particolare, risulterebbe semplice
	 			aggiungere nuovi componenti interessati a questo evento senza apportare nessuna modifica al WasteService stesso.
	 		</li>
	 		
	 		<li>
	 			Disaccoppiamento tra i due componenti: il WasteService non deve per forza conoscere il transport trolley
	 			con l'utilizzo di un evento.
	 		</li>
	 		
	 		<li>
	 			Problemi nella comunicazione: nel caso ci siano problemi nella comunicazione l'evento viene perso.
	 		</li>
	 	</ol>
	 	
	 	<h4> Architettura #3 </h4>
	 	<img src="img/CORE6Image.jpg" alt="img"> <br>
	 	
	 	In questa terza architettura si comunica al transport trolley di andare ad INDOOR attraverso l'utilizzo di una request. <br>
	 	
	 	Caratteristiche della soluzione con request/response:
	 	
	 	<ol class="arabic simple">
	 		<li>
	 			Si evitano i problemi in caso di errori di comunicazione che si avevano con la soluzione
	 			ad evento.
	 		</li>
	 		
	 		<li>
	 			La semantica del messaggio di activate non necesiterebbe veramente di una risposta da parte del trolley.
	 		</li>
	 		
	 		
	 	</ol>
	 	
	 	
	 	<h3> Note </h3>
	 	<ol class="arabic simple">
	 	
	 		
	 		<li>
	 			Dato che il commitente non ha specificato che ci sia la possibilità di trolley multipli si sconsiglia la soluzione ad evento.
	 		</li>
	 	</ol>
	 	
	 	
	 	<h3 id="Problematica_Ritiro_effettuato">  Problematica Ritiro effettuato </h3>
	 	
	 	<h4> Architettura #1 </h4>
	 	<img src="img/CORE3Image.jpg" alt="img"> <br>
	 	
	 	In questa prima architettura il transport trolley emette un evento quando ha effettuato il ritiro del carico.
	 	<br>
	 	Caratteristiche della soluzione ad evento:
	 	<ol class="arabic simple">
	 		
	 		
	 		<li>
	 			L'informazione sarebbe percettibile da un numero qualsiasi di osservatori interessati, senza che
	 			l'azione di osservazione comporti un cambiamento del Transport Trolley. In particolare, risulterebbe semplice
	 			aggiungere nuovi componenti interessati a questo evento senza apportare nessuna modifica al Transport Trolley stesso.
	 		</li>
	 		
	 		<li>
	 			Problemi nella comunicazione: nel caso ci siano problemi nella comunicazione l'evento viene perso.
	 		</li>
	 	</ol>
	 	
	 	Nel caso si presenti un problema della comunicazione durante l'emissione dell'evento, questo avrebbe gravi conseguenza, 
	 	andando a causare una situazione di stallo del wasteService. Per questo motivo si introducono alcune alternative.
	 	
	 	
	 	<h4> Architettura #2 </h4>
	 	<img src="img/CORE4Image.jpg" alt="img"> <br>
	 	
	 	In questa seconda architettura il transport trolley invia un dispatch quando ha effettuato il ritiro del carico.
	 	<br>
	 	Il problema principale di questa soluzione è che si costringe il trolley ad avere conoscenza del WasteService, andando ad accoppiare
	 	i due componenti. Si perde anche la possibilità di realizzare il trolley come un attuatore di comandi esterni, che non ha conoscenza
	 	dei componenti esterni.
	 	
	 	
		<h4> Architettura #3 </h4>
	 	<img src="img/CORE5Image.jpg" alt="img"> <br>
	 	In questa terza architettura il WasteService, subito dopo aver "attivato" il trolley per andare ad INDOOR,
	 	invia una richiesta per verificare se ha effettuato il ritiro. Quando il trolley esegue il ritiro risponde alla richiesta.
	 	
	 	<br>
	 	Questa soluzione permette di sfruttare il vantaggio di quella ad eventi, dove il trolley non è a conoscenza del wasteService;
	 	inoltre, si risolve il problema nel caso la comunicazione non avvenga in modo corretto, dato che il wasteService non riceverà una risposta da parte del trolley.
	 	
	 	<br>
	 	Nel caso in cui per risolvere il problema Ritiro si utilizzi la soluzione #3 (request/response), è possibile
	 	sfruttare il messaggio di response per comunicare di aver eseguito il pickup.
	 	
	 	
	 	<h3 id="Problematica_fine_deposito"> Problematica Fine Deposito </h3>
	 	
	 	<h4> Architettura #1 </h4>
	 	<img src="img/CORE7Image.jpg" alt="img"> <br>
	 	
	 	<h4> Architettura #2 </h4>
	 	<img src="img/CORE8Image.jpg" alt="img"> <br>
	 	
	 	<h4> Architettura #3 </h4>
	 	<img src="img/CORE9Image.jpg" alt="img"> <br>
	 	
	 	Si hanno i problemi menzionati in precedenza per quanto riguarda il tipo di messaggio.
	 	Come conseguenza di fine deposito il WasteService deve anche incrementare il peso corrente del 
	 	carico dei container.
	 	
	 	
	 	<h3 id="Problematica_nuovo_deposito"> Problematica Nuovo Deposito </h3>
	 	
	 	<h4> Soluzione #1 </h4>
	 	Si può sfruttare il fatto che il transport trolley sia un attore con una coda associata e nel caso
	 	in cui il WasteService accetti una richiesta, deposita un messaggio nella coda del trolley, a
	 	prescindere dallo stato in cui esso si trovi. La richiesta verrà processata quando il trolley finisce
	 	il deposito precedente. Nel caso non ci sia nessuna richiesta, tornerà nella posizione HOME.
	 	
	 	<h4> Note </h4>
	 	<ol class="arabic simple">
	 		<li>
	 			Dato che un nuovo wasteTruck può arrivare solamente nel caso in cui l'area di INDOOR sia
	 			libera, questo significa che in coda al trolley si può trovare al più una richiesta.
	 		</li>
	 	</ol>
	 	
	 	<h4> Soluzione #2 </h4>
	 	Il wasteService può aspettare a depositare il messaggio nella coda del trolley e quando il trolley
	 	termina un deposito invia un messaggio per sapere se è presente una nuova richiesta.
	 	<br>
	 	Nel caso si utilizzi una richiesta per segnalare la fine del deposito (problematica precedente) è 
	 	possibile utilizzare la response per segnalare se siano presenti nuove richieste.
	 	<br>
	 	Nel caso nella problematica fine deposito si utilizzi un evento o un dispatch, il WasteService deve
	 	inviare un messaggio per specificare se siano presenti nuove richieste di deposito o meno.
	 	
	 	
	 	
		<h4> Note </h4>
		Il problema di questa soluzione è che si aggiunge una dipendenza tra i componenti e potrebbe causare
		alcuni problemi aggiuntivi. Nel caso della soluzione ad evento si ha sempre il problema in cui
		ci siano dei problemi durante l'invio del messaggio. Questo porterebbe gravi conseguenza.
		<br>
		Nella soluzione con dispatch e request il trolley sarebbe costretto a conoscere il WasteService.
	 	
	 		 	
	 	<h3 id="Problematica_leave_indoor"> Problematica libera area INDOOR </h3>
	 	Il WasteTruck deve liberare l'area di INDOOR dopo che è stato prelevato il carico dal trolley.
	 	<br>
	 	Per quanto riguarda come comunicarlo si ha:
	 	<h4> Soluzione #1 </h4>
	 	Il WasteService invia un messaggio di Dispatch per comunicare che il carico è stato prelevato.
	 	<br>
	 	<img src="img/CORE10Image.jpg" alt="img"> <br>
	 	
	 	<h4> Soluzione #2 </h4>
	 	Si può sfruttare la risposta al messaggio di loadaccepted per comunicare al wasteTruck che il 
	 	carico è stato prelevato e che può liberare l'area di INDOOR.
	 	
	 	<h4> Note </h4>
	 	La prima soluzione risulta essere più comprensibile rispetto alla seconda, anche se utilizza
	 	un messaggio in più.
	 	
	 	
	 	<h3 id="Problematica_container"> Problematica Posizioni Container</h3>
	 	
	 	<h4> Soluzione #1 </h4>
	 	Può essere il WasteService che conosce la posizione dei container e comunica al trolley (quando deve attivarsi) 
	 	in quali coordinate andare.
	 	
	 	<h4> Soluzione #2 </h4>
	 	Può essere il trolley stesso ad essere a conoscenza della posizione dei container. Il problema di questa soluzione
	    è il fatto che si va a cablare la posizione dei container direttamente all'interno del trolley e si perde 
	    la possibilità di realizzare il trolley come un semplice attuatore.
	    
	    <h4> Soluzione #3 </h4>
		Può essere un terzo componente ad avere questa informazione. Nel caso l'informazione sia in un terzo componente
		si può avere il wasteService che chiede la posizione al componente aggiuntivo e la invia al trolley oppure può 
		essere il trolley, che una volta ricevuta dal wasteService la posizione da raggiungere, chieda al componente 
		le coordinate dell'obiettivo.
		
		<br>
		Vantaggi: 
		<ol class="arabic simple">
			<li>
				Scalabilità: nel caso si voglia aggiungere una nuova posizione o cambiare le coordinate di una esistente
				basta semplicemente modificare il nuovo componente senza che vada ad influire in nessun modo con il resto
				dei componenti
			</li>
			<li>
				Nel caso della soluzione dove si ha il WasteService che chiede le coordinate al componente aggiuntivo si 
				continua a vedere il trolley come un attuatore.
			</li>
			
		</ol>
		
		<h3 id="Problematica_percorso"> Problematica percorso trolley </h3>
		Per non cablare l'informazione del percorso direttamente all'interno del trolley è possibile: 
		<h4> Soluzione #1 </h4>
		Fare in modo che il wasteService conosca il percorso da seguire e invii il percorso tramite messaggio al trolley.
		In questo caso non sarebbe nemmeno necessario inviare le coordinate dei container al trolley.
		
		<h4> Soluzione #2 </h4>
		Utilizzare un componente esterno che conosca (e possibilmente possa trovare) il percorso. In questo caso, il 
		wasteService potrebbe chiedere il percorso ed inviarlo direttamente al trolley continuando a pensarlo come un attuatore
		oppure potrebbe essere il trolley a chiedere quale sia il percorso al terzo componente.
		<br>
		Il vantaggio che si ottiene facendo comunicare il wasteService con il componento aggiuntivo è quello citato in 
		precedenza, vale a dire, la possibilità di disaccoppiare il trolley dalla logica di business. Lo svantaggio che
		si ha è nel caso in cui ci siano lunghi percorsi da comunicare al trolley, dovendo inviare messaggi di grandi
		dimensioni.
		
		<h4> Note</h4>
		Dato che all'interno di un magazzino sembra improbabile avere percorsi di grandi dimensioni si consiglia la 
		soluzione dove il trolley viene considerato come un attuatore.
		
		<h3 id="Problematica_peso"> Problematica peso container</h3>
		<h4> Soluzione #1 </h4>
		Può essere il wasteService stesso a tenere il peso dei container. 
		
		<h4> Soluzione #2 </h4>  
		Può essere un componente esterno (container) che tiene traccia del peso del container. Inoltre, si può avere
		un componente per ogni container nel sistema oppure un unico componente che tiene traccia del peso di tutti i container.
		
		
		<h3 id="Problematica_mappa"> Problematica Mappa della stanza e valori preimpostati </h3>
		Dai requisiti si sa che le dimensioni della stanza sono note a priori e anche le posizioni dei punti di interesse
		che possono anche essere considerati come un'unica coordinata (HOME, INDOOR, PLASTICBOX, GLASSBOX).<br>
		Per poter informare i componenti che lo necessitano del valore delle informazioni note apriori è possibile:<br>
		1) Cablare i valori all'interno degli attori stessi<br>
		2) Utilizzare un file di configurazione<br>
		3) Avere un componente ulteriore che conosce queste informazioni<br><br>
		
		Per favorire la riusabilità del software si sconsiglia l'utilizzo della prima soluzione, dato che cambiare la 
		dimensione dell'area nella quale il robot dovrebbe girare comporterebbe modifiche dirette al codice.<br>
		La soluzione con file di configurazione permette di modificare facilmente, senza cambiare il codice, il valore
		delle informazioni di interesse.<br>
		Utilizzare un componente esterno semplicemente mantenere queste informazioni risulta troppo costoso.<br>
		
		<pre>
		{
		    <key4>"LOCATION"</key4>: {
		        <key4>"HOME"</key4>: [0, 0],
		        <key4>"INDOOR"</key4>: [16, 0],
		        <key4>"PLASTICBOX"</key4>: [16, 19],
		        <key4>"GLASSBOX"</key4>: [0, 19]
		    },
		    <key4>"MAXPB"</key4>: 500,
		    <key4>"MAXGB"</key4>: 500,
		    <key4>"DLIMIT"</key4>: 40
		}
		</pre>
		
		<h3 id="Problematica_rappresentazione"> Problematica Rappresentazione della posizione di INDOOR, HOME e dei CONTAINER</h3>
		
		Le possibili soluzioni trovate sono: <br>
		
		<h4> Coordinate GPS </h4>
		L'utilizzo di coordinate GPS richiede la conoscenza delle coordinate GPS dei luoghi d'interesse e la presenza di un 
		GPS a bordo del DDR robot.<br>
		Grazie a questa soluzione si potrebbe ottenere una grande precisione per quanto riguarda la posizione del robot, ma
		come lato negativo si ha che il costo per una soluzione del genere risulta estremamente alto e più complesso
		da gestire.
		
		<h4> Coordinate Cartesiane </h4>
		L'utilizzo delle coordinate cartesiane impone la necessità di scegliere un'unità di misura in modo da mappare
		opportunamente la Service Area, si potrebbero sfruttare le dimensioni del robot per fare questo, dato che sappiamo
		che il robot ha lato di dimensioni RD.
		I vantaggi principali di questa soluzione sono il fatto di non necessitare di componenti costosi come per quanto 
		riguarda la soluzione basata a GPS e una complessità minore.<br>
		Lo svantaggio principale è la necessità di dover mappare la stanza prima di poter iniziare effettivamente a lavorare. 
		Nel caso in cui la stanza possa avere ostacoli, inoltre, comporterebbe avere delle contromisure sul fatto che il percorso
		da utilizzare potrebbe non essere disponibile.
		
		<br><br>
		
		La Software House ha a disposizione software che permette di realizzare questa soluzione velocemente: <br>
		<a href="https://github.com/anatali/issLab2022/tree/main/unibo.mapperQak22">unibo.mapperQak22</a> Permette di eseguire il mapping di una stanza<br>
		<a href="https://github.com/anatali/issLab2022/tree/main/unibo.planner22">unibo.planner22</a> Permette di identificare il percorso una volta forniti il punto di partenza e la destinazione<br>
		<a href="https://github.com/anatali/issLab2022/tree/main/unibo.pathexecutor">unibo.pathexecutor</a> Permette di eseguire il path trovato dal planner.<br>
		

		
		<h3 id="Problematica_posizione_trolley"> Problematica Posizione del trolley nella stanza </h3>
		Anche in questo caso si ha la possibilità che sia il trolley stesso a sapere la sua posizione oppure il waste service
		mantenga informazioni per quanto riguarda gli spostamenti che il robot sta eseguendo. <br>
		Sempre con l'idea di voler mantenere il trolley il più independente possibile si consiglia di lasciare questa
		responsabilità al waste service.
		<br> <br>
		In seguito ad interazione con il commitente sappiamo che la posizione del trolley nella stanza può essere espressa
		tramite le posizioni di interesse (HOME, INDOOR, GLASS, PLASTIC).
		
			 	
	 	<h3> Soluzione proposta </h3>
	 	L'idea principale di questa soluzione è quella di rendere il trolley un attuatore, senza che
	 	abbia conoscenza degli altri componenti.
	 	
	 	<br>
	 	Per risolvere il problema Ritiro e RitiroEffettuato viene utilizzato una request/response per
	 	comunicare al trolley di iniziare il compito Proattivo (activate) e la response viene utilizzata per 
	 	comunicare di avere eseguito il pickup.
	 	<br>
	 	Per comunicare al WasteTruck di liberare l'area di input in seguito al pickup da parte del trolley
	 	viene utilizzato un messaggio di Dispatch da parte di WasteService.
	 	<br>
	 	Per comunicare al WasteService di avere terminato il deposito, il trolley invia un evento 
	 	(LoadDeposit).
	 	<br>
	 	Infine, per quanto riguarda la problematica Nuovo Deposito si adotta la soluzione #1, dove le 
	 	richieste vengono messe in code al trolley appena vengono accettate dal WasteService.
	 	
	 	<h4> Note </h4>
	 	Si considera l'utilizzo di un evento per risolvere il problema del fine deposito, poichè anche 
	 	nel caso in cui l'evento venga perso per problemi di comunicazione, dato che tale evento viene
	 	utilizzato esclusivamente per l'aggiornamento del peso corrente dei Container, anche in caso
	 	di errore, esso viene gestito in maniera semplice dal WasteService.
	 	
	 	<h3> Soluzione Proposta</h3>
	 	Al termine dell'analisi del problema si propone una possibile soluzione che tiene conto di tutte le 
	 	considerazioni fatte precedentemente.<br>
	 	Il principale obiettivo di questa soluzione è quello di mantenere il trolley come un attuatore e il 
	 	wasteService come la "mente" delle operazioni. Per fare questo molte comunicazioni vengono proposte
	 	come request/response, in modo che il trolley non debba essere a conoscenza di componente specifici.
	 	
	 	<br>
	 	N.B. Questa soluzione NON sarà la soluzione finale, nè vincola i progettisti a utilizzare la stessa soluzione
	 	ai problemi mostrati in precedenza.<br>
	 	Serve, principalmente, per avere un riscontro da parte del committente.
	 	<br>
	 	<br>
	 	<table style="width:80%">
            <thead>
              <tr>
                <th>Messaggio</th>
                <th>Tipo </th>
                <th> Descrizione </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>storeLoad </td>
                <td> Request</td>
                <td> Richiesta inviata dal truck per iniziare l'operazione di deposito</td>
              </tr>
              <tr>
                <td>loadAccepted</td>
                <td>Response</td>
                <td> Risposta affermativa da parte del wasteService al truck</td>
              </tr>
              <tr>
                <td>loadRejected</td>
                <td>Response</td>
                <td> Risposta negativa da parte del wasteService al truck</td>
              </tr>
              <tr>
                <td>leaveIndoor</td>
                <td> Dispatch </td>
                <td> Messaggio utilizzato per segnalare al wasteTruck di liberare l'area di indoor</td>
              </tr>
              <tr>
                <td> moveToDestination </td>
                <td> Request </td>
                <td> Richiesta da parte del wasteService per segnalare al trolley di muoversi in una
                determinata posizione</td>
              </tr>
              <tr>
                <td> destinationReached </td>
                <td> Response</td>
                <td> Risposta da parte del trolley per segnalare di aver raggiunto la destinazione</td>
              </tr>
              <tr>
                <td> pickup</td>
                <td> Request </td>
                <td> Richiesta da parte del wasteService per segnalare al trolley di eseguire l'azione
                di pickup</td>
              </tr>
              
              <tr>
                <td> pickupDone</td>
                <td> Response </td>
                <td> Risposta del trolley alla richiesta di pickup</td>
              </tr>
              
              <tr>
                <td> deposit</td>
                <td> Request </td>
                <td> Richiesta da parte del wasteService per segnalare al trolley di eseguire l'azione
                di deposit</td>
              </tr>
              
              <tr>
                <td> depositDone</td>
                <td> Response </td>
                <td> Risposta del trolley alla richiesta di deposit</td>
              </tr>
              
              <tr>
                <td> findPath</td>
                <td> Request </td>
                <td> Richiesta inviata dal trolley al pathFinder per richiedere un path ad una determinata
                destinazione</td>
              </tr>
              
              <tr>
                <td> path</td>
                <td> Response </td>
                <td> Risposta del pathFinder contenente il path che il trolley deve percorrere</td>
              </tr>
            </tbody>
            </table>
	 	
	 	<h4> Architettura Finale </h4>
	 	In questa architettura il wasteTruck viene rappresentato come un attore solamente per scopi
	 	prototipali. In fasi successive verrà trasformato in una entità appropriata. <br>
	 	
            
	 	<img src="img/wasteserviceSprint1Problemarch.png" alt="img"> <br>
	 	
	 	<h3> Modello eseguibile analisi del Problema </h3>
	
		<a href="./qak/WasteServiceAnalisiProblemaAmbrogini.qakt" >Modello Analisi del problema</a>
	<br>
	 	
	 	
	 </div>
	
	<h2>Test plans</h2> 
	
	<div class="remark">
		Vengono riportati sia i test plan mostrati precedentemente durante la fase di analisi dei requisiti e ulteriori
		test per verificare alcune delle nuove feature introdotte nella fase di Analisi del problema.<br>
		Nei test si presuppone che sia il test stesso ad inviare il messaggio che normalmente sarebbe inviato dal wastetruck 
		per far iniziare la procedura.
	
		<br><br>
		
		Viene introdotta una classe di supporto per poter creare degli observer che sfruttano
		CoAP.
		
		<br><a href="./test/TestObserver.java" >Test Observer</a> <br>
		
		<br>

		<b>Test Request</b><br>
		<a href="./test/ProblemAnalysis/TestRequest.java" >Test request</a> <br>
		
		<ul>
			<li>
				TestRequestOk: il test invia una richiesta di storeload con un carico che possa essere accettato e si verifica
				che il waste service invii la risposta corretta (loadaccepted)
			</li>
			<li>
				TestRequestFail: il test invia una richiesta di storeload con un carico molto elevato e si verifica
				che il waste service invii la risposta corretta (loadrejected)
			</li>
		</ul>
		
		<br><br>
		
		<b>Test Deposit</b><br>
		<a href="./test/ProblemAnalysis/TestDeposit.java" >Test deposit</a> <br>
		
		<ul>
			<li>
				TestDepositOk: il test controlla che il trolley si fermi in tutte le posizioni corrette per poter effettuare un 
				deposito.
			</li>
			<li>
				TestDepositFail: il test controlla che nel caso si inseriscano il posizioni errate venga generato un errore.
			</li>
			
			<li>
				TestDeposit: controlla che il peso all'interno del container sia stato aggiornato correttamente
			</li>
		</ul>
		
		<br><br>
		
		<b>Test End Deposit</b><br>
		<a href="./test/ProblemAnalysis/TestEndDeposit.java" >Test end deposit</a> <br>
		
		<ul>
			<li>
				TestDepositReturnHome: controlla che il trolley torni ad home nel caso non ci siano nuove richieste da servire.
			</li>
			<li>
				TestDepositAnotherRequest: controlla che, nel caso ci siano nuove richieste una volta terminato il deposito, il trolley torni ad indoor
				e non vada ad home.
			</li>
			
		</ul>
		
		<br><br>
		
		<b>Test Update Weigths</b><br>
		<a href="./test/ProblemAnalysis/TestUpdateWeights.java" >Test Update Weights</a> <br>
		
		<ul>
			<li>
				TestUpdateOk: Controlla che i pesi siano aggiornati correttamente.
			</li>
			<li>
				TestUpdateFail: Controlla che, nel caso in cui i pesi siano aggiornati erroneamente, si segnali l'errore.
			</li>
			
		</ul>
		
		
	</div>
	
	
	
	<h2>Project</h2> 
	<div class="remark">
	<h3> Waste Service </h3>
	Il primo compito della progettazione sarà quello di separare i vari compiti attribuiti al WasteService in Analisi del problema.
	
	<ul>
		<li>
			TruckGui: una entità principale che si occupa di ricevere le richieste di deposito da parte del WasteTruck ed inizia
			la procedura di deposito
		</li>
		
		<li>
			wasteservice: componente che si occupa di gestire il requisito Core definito in analisi dei requisiti. In particolare, 
			essendo che il trolley viene trattato come un semplice attuatore, la parte Core del waste Service si occuperà
			di segnalare tutti i movimenti che il trolley deve fare e di tenere traccia della sua posizione.
		</li>
		
		<li>
			Storage: per scopo prototipale, in analisi del problema, il compito dello storage è stato fornito al WasteService
			cablando i dati all'interno di esso. In progettazione verrà aggiunto un nuovo componente, che interagirà con il 
			WasteService, che si occuperà proprio di gestire i pesi nei vari container.
		</li>
		
		<li>
			Un file di configurazione per quanto riguarda i parametri (come la posizione dei container).
		</li>
	
	</ul>
	
	
	<h4> TruckGUI </h4>
	Questo componente viene realizzato come un'applicazione web realizzata tramite Spring per facilitarne lo sviluppo.
	<br>
	La truckGUI mostrerà, inizialmente, una pagina nella quale il driver possa inserire le informazione
	del carico che vuole depositare. Queste informazioni verranno inviate allo storage manager, per controllare
	di avere abbastanza spazio per contenere il carico e verrà inviato il messaggio di loadaccept/loadreject.
	<br>
	<br>
	<a href="../truckGui/unibo.wasteservice/src/main/resources/templates/truck.html" > Interfaccia per il truck driver</a> 
	<br>
	<br>
	Infine, l'applicazione Web andrà ad interagire con il componente Core del WasteService per poter 
	iniziare la vera e proprio azione di pickup/deposito. Per fare questo si necessita di introdurre
	un nuovo scambio di informazioni e quindi un nuovo messaggio.
	Dato che si necessita di una risposta, per sapere quando liberare il WasteTruck dall'area di deposito,
	questa comunicazione verrà realizzata come una request/reply. 
	<br>
	
	<pre><key2>Request</key2> startDeposit : startDeposit( TYPE ) <br><key2>Reply</key2> leaveIndoor : leaveIndoor(_)</pre>
	
	<br>
	Quando l'applicazione web deve avviare la fase di deposito invia il messaggio di startDeposit al 
	wasteService e quando il trolley ha effettivamente ritirato i materiali da Indoor il wasteService invia
	la reply leaveIndoor all'applicazione web.
	<br>
	Il messaggio di Dispatch leaveIndoor, mostrato in analisi, diventa ora una reply.
	
	
	
	<h4> WasteService </h4>
	Il componente Core del WasteService si occuperà di gestire la logica di business dell'applicazione e
	inviare i vari messaggi per poter comandare il transportTrolley come è stato mostrato con il WasteService
	nel prototipo dell'analisi del problema.
	<br>
	Quando il Core riceverà il messaggio di startDeposit da parte della truckGUI, si avviano le operazioni
	necessarie per poter eseguire tutte le azioni per arrivare al deposito dei materiali all'interno del 
	container corretto.
	
	<br>
	Al termine dell'azione di pickup da parte del Trolley, il Core invierà la reply introdotta 
	precedentemente: "leaveIndoor" alla truckGUI, in modo da poter liberare l'area di deposito.
	
	
	<h4> StorageManager </h4>
	Il componente StorageManager si occuperà di gestire il peso corrente nei container e di valutare se sia 
	possibile depositare il carico specificato da un WasteTruck che si trova nell'area di scarico.
	<br>
	Ogni volta che il peso verrà modificato il compenente utilizzerà il protocollo CoAP per segnalare la 
	modifica. Questo facilita sia la fase di testing per verificare che il sistema funzioni correttamente, sia
	permette a componenti interessati a questi cambiamenti di poterli "ascoltare".
	
	<br>
	Per poter realizzare queste nuove comunicazioni servono nuovi messaggi.
	<pre><key2>Request</key2> storeRequest : storeRequest(MAT, QNT) <br><key2>Reply</key2> storeRequestReply : sotreRequestReply(ANS)</pre>
	
	<br>
	Il componente Handler del WasteService utilizzerà il messaggio di request "storeRequest" per poter
	chiedere allo StorageManager se sia possibile depositare il materiale MAT con quantità QNT, lo 
	StorageManager, attraverso la reply "storeRequestReply", segnalerà se sia possibile o meno farlo.
	
	<br>
	Per poter aggiornare i pesi, in seguito alla deposit da parte del trolley, si introduce un messaggio,
	inviato dal wasteservice allo storage manager , per segnalare l'avvenuto deposito. Quando lo StorageManager riceve questo
	messaggio si occuperà di aggiornare i pesi ed inviare un messaggio tramite CoAP per comunicare il nuovo
	valore del peso dei container.
	
	<pre><key2>updateResource</key2>[# "glass($CurrentGlassWeight), plastic($CurrentPlasticWeight)" #]</pre>
	
	<h4> File di configurazione</h4>
	Infine, viene introdotto un file di configurazione nella quale vengono inseriti tutti i valori 
	preimpostati in modo da non doverli cablare nel codice.
	
	
	<pre>
		{
		    <key4>"LOCATION"</key4>: {
		        <key4>"HOME"</key4>: [0, 0],
		        <key4>"INDOOR"</key4>: [16, 0],
		        <key4>"PLASTICBOX"</key4>: [16, 19],
		        <key4>"GLASSBOX"</key4>: [0, 19]
		    },
		    <key4>"MAXPB"</key4>: 500,
		    <key4>"MAXGB"</key4>: 500,
		    <key4>"DLIMIT"</key4>: 40
		}
		</pre>
	
	
	<h3> Transport Trolley </h3>
	Seguendo le indicazioni dell'analisi del problema si è voluto realizzare il transportTrolley come
	un attuatore. <br>
	Tuttavia si ha una parte di logica di business che non può essere eliminata dal trolley, in particolare,
	la parte nella quale si necessita di fare il pickup ed il deposito dei materiali.
	<br>
	In progettazione si vogliono separare queste due parti del transportTrolley:
	
	<ul>
		<li>
			TransportTrolleyHandler: Un primo componente che si occupi proprio di fare queste operazioni e di fare da "manager"
			delle richieste che arrivano da parte del WasteService. In particolare, in analisi
			era stato evidenziata la necessità di un componente che trovasse un percorso verso la destinazione
			inviata dal WasteService. <br>
			Questo componente si occuperà, prima di tutto, di chiedere il percorso al componente mostrato 
			in analisi "PathFinder" e successivamente di inviare il percorso al componente che si occupa
			di muovere il trolley lungo tale percorso.
	
		</li>
		<li>
			TransportTrolleyMover: Un secondo componente che si occupi effettivamente dei movimenti da eseguire per raggiungere
			la destinazione specificata. In particolare, si è pensato di utilizzare il BasicRobot e il 
			PathExec (componenti già realizzati dalla software house per poter effettivamente muovere
			il robot).
			BasicRobot permette di implementare il movimento del robot in modo indipendente dalla tecnologia
			utilizzata, il che lo rende un componente fondamentale in fase di testing e sviluppo.
		</li>
	</ul>
	
	
	<h3> Sprint Review </h3>
	In seguito a determinate considerazioni si è deciso di unificare il PathFinder introdotto in analisi
	del problema con il TransportTrolleyMover mostrato in Progettazione.
	
	
	<h3>Architettura finale</h3>
	Vengono elencati i messaggi aggiunti in questa fase. <br>
	Per vedere quelli già esistenti fare riferimento all'analisi del problema. <br><br>
	
	<table style="width:80%">
		<thead>
		  <tr>
			<th>Messaggio</th>
			<th>Tipo </th>
			<th> Descrizione </th>
		  </tr>
		</thead>
		<tbody>
		  <tr>
			<td> startDeposit </td>
			<td> Request</td>
			<td> Nuovo messaggio che viene inviato da TruckGui a WasteService per iniziare un nuovo deposito</td>
		  </tr>
		  <tr>
			<td> leaveIndoor </td>
			<td> Response</td>
			<td> Stessa funzionalità dell'analisi, ma ora è la response di startDeposit</td>
		  </tr>
		  <tr>
			<td> storageAsk</td>
			<td> Request </td>
			<td> Richiesta allo storage manager della quantità attuale di un certo materiale</td>
		  </tr>
		  <tr>
			<td> storageAmount </td>
			<td> Response </td>
			<td> Risposta a storageAsk</td>
		  </tr>
		  <tr>
			<td> storeRequest </td>
			<td> Request </td>
			<td> Richiesta da parte di TruckGUI di un nuovo deposito, viene verificato che ci sia spazio</td>
		  </tr>
		  <tr>
			<td> loadAccepted</td>
			<td> Response</td>
			<td> Risposta affermativa a storeRequest</td>
		  </tr>
		  <tr>
			<td>loadRejected</td>
			<td>Response</td>
			<td> Risposta negativa a storeRequest</td>
		  </tr>
		  
		  <tr>
			<td> updateWeights</td>
			<td> Dispatch </td>
			<td> Messaggio per eseguire l'aggiornamento dei pesi</td>
		  </tr>
		</tbody>
		</table>
	<br>
	<br>

	<a href="./qak/newWasteServiceProject.qak" >Modello waste service</a>
	<br>
	<a href="./qak/newTransportTrolleyProject.qak" >Modello transport trolley</a>
	<br>
	<br>
	<img src="img/final_architecture.jpg" alt="img"> <br>
	
	</div>
	
	<h2>Testing</h2>
	<div class="remark">
	Sono stati adattati i test plan mostrati precedentemente in base alle modifiche effettuate al sistema.
	<br>	
	Essendo il sistema distribuito, si ha la necessità di avviare il sistema esternamente con l'utilizzo
	di docker prima di lanciare i test.
	<br><br>

	<b>Test Request</b><br>
		<a href="./test/Project/TestRequest.java" >Test request</a> <br>
		
		<ul>
			<li>
				TestRequestOk: il test invia una richiesta di storeload con un carico che possa essere accettato e si verifica
				che il waste service invii la risposta corretta (loadaccepted)
			</li>
			<li>
				TestRequestFail: il test invia una richiesta di storeload con un carico molto elevato e si verifica
				che il waste service invii la risposta corretta (loadrejected)
			</li>
		</ul>
		
		<br><br>
		
		<b>Test Deposit</b><br>
		<a href="./test/Project/TestDeposit.java" >Test deposit</a> <br>
		
		<ul>
			<li>
				TestDepositOk: il test controlla che il trolley si fermi in tutte le posizioni corrette per poter effettuare un 
				deposito.
			</li>
			<li>
				TestDepositFail: il test controlla che nel caso si inseriscano il posizioni errate venga generato un errore.
			</li>
			
			<li>
				TestDeposit: controlla che il peso all'interno del container sia stato aggiornato correttamente
			</li>
		</ul>
		
		<br><br>
		
		<b>Test End Deposit</b><br>
		<a href="./test/Project/TestEndDeposit.java" >Test end deposit</a> <br>
		
		<ul>
			<li>
				TestDepositReturnHome: controlla che il trolley torni ad home nel caso non ci siano nuove richieste da servire.
			</li>
			<li>
				TestDepositAnotherRequest: controlla che, nel caso ci siano nuove richieste una volta terminato il deposito, il trolley torni ad indoor
				e non vada ad home.
			</li>
			
		</ul>
		
		<br><br>
		
		<b>Test Update Weigths</b><br>
		<a href="./test/Project/TestUpdateWeights.java" >Test Update Weights</a> <br>
		
		<ul>
			<li>
				TestUpdateOk: Controlla che i pesi siano aggiornati correttamente.
			</li>
			<li>
				TestUpdateFail: Controlla che, nel caso in cui i pesi siano aggiornati erroneamente, si segnali l'errore.
			</li>
			
		</ul>
	</div>
	
	<h2>Deployment</h2>
	<div class="remark">
	Per eseguire il deployment si è utilizzato docker e si sono separate le immagini dei vari componenti.
	
	<br>
	<a href="./wasteservice_Sprint1.yaml" >File docker compose per eseguire il sistema</a>
	<br>
	
	Viene anche fornito un ambiente virtuale nella quale è possibile osservare il robot muoversi. <br>
	Questo software era già disponibile alla software house tramite il progetto: virtualrobot2020.

	<br>
	<br>

	<table style="width:40%">
		<thead>
		  <tr>
			<th>Service</th>
			<th>Port</th>
		  </tr>
		</thead>
		<tbody>
		  <tr>
			<td> WasteService </td>
			<td> 8049</td>
		  </tr>
		  <tr>
			<td> TransportTrolley </td>
			<td> 8051</td>
		  </tr>
		  <tr>
			<td> TruckGUI </td>
			<td> 8080</td>
		  </tr>
		  <tr>
			<td> VirtualRobot </td>
			<td> 8090</td>
		  </tr>
		  <tr>
			<td> BasicRobot </td>
			<td> 8020</td>
		  </tr>
		 
		</tbody>
		</table>



	</div>
	 
	<!-- USEFUL
	<table style="width:100%" border="1">
	<tr>
	<td style="width:50%">
	</td>
	<td></td>
	</tr>
	</table>
	-->
		      	
	<br/><br/> 	

	
	<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
	By Thomas Ambrogini email: thomas.ambrogini@studio.unibo.it  
	<img src="./img/ThomasAmbrogini.jpg" alt="mbot" width="15%" height="15%">
	</div> 
</body>
</html>