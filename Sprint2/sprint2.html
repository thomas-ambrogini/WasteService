<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />


    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
   
   
  	<link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

	<title>Sprint2 Thomas Ambrogini</title>
		
</head>
    
<body>
	<div id="top">
	<h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font> </h1>
	</div>  
	
	<div class="body"> 
	<h2>Introduction</h2>
	<div  class="remark">
		Tema finale dell'esame di ingegneria dei sistemi software: WasteService
	</div>
	 
	<h2>Requirements</h2>
	
	<a class="headerlink" href="./TemaFinale22.html" title="Permalink to this headline">Testo requisiti fornito dal committente</a>
	
	
	
	 
	
	<h2>Requirement analysis</h2>
	
	<div class="remark">
	<section id="requisiti-funzionali">
		<h3>Requisiti funzionali<a class="headerlink" href="#requisiti-funzionali" title="Permalink to this headline">¶</a></h3>
		
		
		Requisiti riguardanti LED e SONAR
		<ol class="arabic simple">
			<li>
				<p><em>Led Off</em>: nel caso in cui il trolley si trovi nella posizione HOME.</p>	
			</li>
			<li>
				<p><em>Led Blinks</em>: mentre il trolley si sta muovendo.</p>	
			</li>
			<li>
				<p><em>Led On</em>: quando il trolley è stoppato.</p>	
			</li>
			<li>
				<p><em>Sonar</em>: nel caso in cui il sonar misuri una distanza minore di DLIMIT, il trolley deve essere stoppato. Verrà riattivato quando il sonar rileverà una distanza maggiore di DLIMIT </p>
			</li>
		</ol>
		
	
	
	
	<h3> Led </h3>
	
	Per quanto riguarda la gestione del LED, il committente ha fornito diversi materiali: led25GpioTurnOn.sh che
	permette di accendere un led e led25GpioTurnOff.sh che permette di spegnere un led.
	<br>
	Inoltre, l'azienda dispone di un progetto che permette di gestire un Led in modo semplice, attraverso
	Java, it.unibo.radarSystem22.domain, che si consiglia di utilizzare.
	<br> <br>
	
	Dai requisiti è possibile notare tre diversi comportamente che il led deve esibire:
	
	<ul>
		<li>
			TurnOn: accensione del Led. il led deve essere acceso quando il tranport trolley è fermo, in seguito ad un interrupt 
			dovuto al sonar.
		</li>	
		<li>
			TurnOff: spegnimento del Led. Il led deve essere spento quando il trolley si trova nella 
			posizione HOME.
		</li>
		<li>
			Blink: spegnimento ed accensione in modo alterno. Il led deve lampeggiare quando il trolley
			si sta muovendo.
		</li>
	</ul>
	
	Il progetto che è stato sviluppato dalla software house permette di eseguire solamente i primi due
	comportamente e si ha quindi la necessità di implementare il terzo comportamento.
	<br>
	Il Led deve essere realizzato come attore per poter interagire con gli altri componenti del sistema.

	<br>
	<br>
	<a href="./qak/led.qakt" >Modello led analisi requisiti</a>
	<br>
	
	<h3> Sonar </h3>
	Il Sonar è un dispositivo di input che emette la distanza dall'ostacolo più vicino ad esso.<br>
	Per dare conoscenza agli altri componenti del sistema della distanza rilevata si possono utilizzare 
	due strategie: 
	
	<ul>
		<li>
			Polling: Il componente interessato ai dati prodotti dal dispositivo di input invoca un metodo
			del sonar per ricevere il primo dato disponibile.
		</li>
		<li>
			Observer: il componente consumatore dei dati si relaziona con il dispositivo di input secondo
			il pattern observer, lasciando il sonar come un generatore di dati che non si interessa
			dei destinatari delle proprie informazioni.
		</li>
		
	</ul>
	
	
	Anche nel caso del Sonar, il committente fornisce del materiale da utilizzare: SonarAlone.c che permette
	di ricevere i valori di un sonar collegato al Raspberry Pi.<br>
	Dai requisiti sul sonar si sono notati due principali comportamenti relativi al sonar:
	
	<ul>
		<li>
			Stop: nel caso in cui la distanza sia minore di DLIMIT, il trolley deve fermarsi.
		</li>
		<li>
			Resume: nel caso in cui la distanza sia maggiore di DLIMIT, il trolley deve ripartire con le
			sue funzioni.
		</li>
	</ul>
	
	I tipi di comunicazione che il sonar andrà ad utilizzare per comunicare con il resto del sistema
	verranno definiti in fase di analisi del problema.
	
	Il sonar deve essere realizzato come attore per poter interagire con gli altri componenti del sistema.
	
	<br>
	<br>
	<a href="./qak/sonar.qakt" >Modello sonar analisi requisiti</a>
	<br>
	
	
	<h3> Problemi da analizzare</h3>
	
	<h4> Tipo di interazione con il Led</h4>
	Quale tipo di comunicazione per fare eseguire al led le varie operazioni?
	
	<h4> Stato del trolley</h4>
	Come fa il led a sapere lo stato del trolley?
	
	<h4> Interazione con il Led</h4>
	Quale componente deve interagire con il Led?
	
	<h4> Tipo di interazione per i messaggi del Sonar</h4>
	Che tipo di comunicazione bisogna usare per inviare i messaggi del sonar (resume/stop)?
	
	<h4> Modo in cui il Sonar invia i dati registrati </h4>
	Che tipo di comunicazione si vuole utilizzare per comunicare i dati che il sonar registra?
	
	<h4> Analisi distanze</h4>
	Quale componente analizza le distanze rilevate dal sonar?
	
	</div>
	
	<h2>Problem analysis</h2>

	 
	 <div class="remark">
	 
	 
	 	<h3>Tipo di Interazione con il Led</h3>
	 		Per segnalare al led di doversi accendere/spegnere/lampeggiare esistono diverse soluzioni.<br>
	 		
	 		<h4> Dispatch </h4>
	 		<pre><key2>Dispatch</key2> blink   : blink(_)<br><key2>Dispatch</key2> turnon  : turnon(_)<br><key2>Dispatch</key2> turnoff : turnoff(_)</pre>
	 		Potrebbe anche essere realizzato come un solo messaggio e si specifica nell'argomento quale
	 		azione eseguire.
	 		
	 		<h4> Evento </h4>
	 		<pre><key2>Event</key2> ledStatus   : ledStatus(Status)</pre>
	 		Si potrebbe utilizzare un evento per poter specificare al led di cambiare il prorio stato.
	 		Il principale vantaggio di una soluzione ad eventi è la grande estendibilità che garantisce, dato
	 		che nel momento in cui si vanno ad aggiungere nuovi led, basta che si mettano in ascolto 
	 		dell'evento.
			<br>
			Lo svantaggio principale dell'evento è la sicurezza nella consegna del messaggio. Nel caso si 
			perda un segnale di blink non sarebbe un problema, ma diventerebbe un problema nel momento in 
			cui si perda un segnale di on o off.
	 
		<h3>Stato del trolley</h3>
		Nello sprint1 non si aveva necessità di conoscere lo stato del trolley (active, stopped, idle) e
		quindi non si ha ancora un componente che lo emetta. <br>
		
		<h4> Evento </h4>
		Per poter comunicare lo stato del trolley si pensa di poter utilizzare una soluzione ad eventi, in
		modo che tale evento possa successivamente essere anche ricevuto dalla GUI.
		
		<h4> CoAP observable </h4>
	 	Essendo il trolley sviluppato come Attore Qak, esso risulta essere una risorsa CoAP observable ed
	 	è, quindi, possibile sfruttare questa caratteristica andando a creare un observer che analizzi i
	 	cambiamenti di stato del trolley.
	 	
	 	<br>
	 	
	 	Si può anche discutere su quale componente debba emettere l'informazione. Da un lato potrebbe 
	 	essere delegata al WasteService, dall'altro potrebbe essere il transportTrolley ad emettere
	 	l'informazione.<br>
	 	Essendo lo stato del trolley strettamente legato al trolley stesso sembrerebbe essere una soluzione
	 	più intuitiva e ragionevole.
	 	
	 	<h3> Interazione con il led</h3>
	 	<h4> WasteService </h4>
	 	In una prima soluzione potrebbe essere il wasteService che si occupa di segnalare al led se 
	 	spegnersi o accendersi o lampeggiare.
	 	<br>
	 	Anche se questa soluzione permetterebbe di delegare la maggior parte della logica di business al 
	 	WasteService, comporta un costo di overhead nel numero di messaggi da scambiare, soppratutto nel 
	 	caso in cui si decida di lasciare al transportTrolley la responsabilità di comunicare lo stato nella
	 	quale esso si trovi.
	 	
	 	<h4> Transport Trolley</h4>
	 	Potrebbe essere il transport Trolley a comunicare direttamente al led quale azione eseguire.
	 	<br>
	 	Si sconsiglia fortemente questa soluzione, dato che porterebbe ad aggiungere al trolley grosse 
	 	responsabilità per quanto riguarda la logica di business.
	 	
	 	<h4> Gestore del led </h4>
	 	Si potrebbe realizzare un ulteriore componente che osservi lo stato del trolley (nel caso in cui si 
	 	scelga la soluzione basata su CoAP oppure che esamini gli eventi nel caso della prima soluzione) e 
	 	segnali al led di eseguire le varie operazioni.
	 	
	 	
	 	
	 	
	 	
	 	<h3>Tipo di interazione con il sonar</h3>
	 	
	 	Il sonar ha la necessità di comunicare con il resto del sistema per bloccare/riprendere il percorso
	 	del trolley.
	 	Data l'importanza di queste operazioni si sconsiglia una soluzione basata ad eventi.
	 	
	 	<h4> Dispatch </h4>
	 	<pre><key2>Dispatch</key2> stop   : stop(_)<br><key2>Dispatch</key2> resume  : resume(_)<br></pre>
	 	
	 	
	 	<h4> Request/Respone</h4>
	 	Questa comunicazione potrebbe anche essere realizzata tramite request/response. In questo caso, la
	 	response potrebbe essere utilizzata come segnale di ACK per essere sicuri che l'operazione sia
	 	stata ricevuta correttamente.
	 	<br>
	 	Considerando che questi tipi di messaggi dovrebbero essere piuttosto rari, l'overhead generato dalla
	 	risposta risulta essere completamente trascurabile.
	 	<br>
	 	In questo modo si ha la possiblità di realizzare a livello applicativo un comportamento in caso
	 	il messaggio non venga consegnato.
	 	<pre><key2>Request</key2> stop   : stop(_)<br><key2>Reply</key2> stopAck  : stopAck(_)<br></pre>
	 	
	 	
	 	<h3>  Modo in cui il Sonar invia i dati registrati </h3>
	 	
	 	<h4> Eventi </h4>
	 	<pre><key2>Event</key2> distance   : distance(DIST)</pre>
		Il Sonar potrebbe emettere ad ogni aggiornamento sulla distanza un evento contenente la nuova 
		distanza, ed i componenti interessati del sistema potranno ricevere tale informazione. <br>
		Considerando che potrebbero esserci diversi componenti interessati a questa informazione, 
		anche per possibili evoluzioni del progetto, potrebbe essere una buona soluzione.
		
		<br><br>
		
		<h4> CoAP </h4>
		Essendo un attore QaK è possibile analizzare le sue informazioni attraverso CoAP.<br> Il principale
		svantaggio di questa soluzione è il fatto che il componente che interagisce con il sonar deve 
		effettivamente conoscerlo, a differenza della soluzione tramite eventi.
		
		<h4>Note</h4>
		Come citato in precedenza, nel caso in cui ci possano essere diversi componenti interessati alla
		distanza emessa dal sonar, la soluzione ad eventi risulta preferibile. <br>
		Nel caso in cui si usasse CoAP ci sarebbe un'interazione request/response ogni volta che un 
		componente sia interessato alla distanza e questo potrebbe sovraccaricare il sistema.<br>
		Quindi, anche per ragioni di scalabilità, si consiglia la soluzione ad eventi.
		
		<br><br>
	 	
	 	
	 	
	 	<h3> Analisi distanze</h3>
	 	<h4> Waste Service</h4>
		Il waste Service potrebbe analizzare le distanze rilevate dal sonar per poi mandare i comandi
		direttamente al Trolley.<br>
		In questo modo si vanno ad aggiungere ulteriori responsabilità al wasteService.
		
		<h4> Trolley </h4>
		Il trolley potrebbe analizzare le distanze e quando trova una distanza minore di DLIMIT, si potrebbe
		fermare. <br>
		A livello implementativo potrebbe risultare la soluzione più semplice, ma aumenta l'accoppiamento
		fra i componenti e si perde la possiblità di realizzare il trolley come attuatore.
		
		<h4> Componente aggiuntivo </h4>
		Un ulteriore componente potrebbe essere inserito nel sistema per poter analizzare le distanze, e 
		nel caso sia opportuno inviare al trolley il segnale per poter stoppare/riprendere le sue
		azioni. <br>
		Questa soluzioni risulta la più flessibile.
	 	
	 	
	 	<h3> Chi riceve il comando per bloccare/riprendere l'esecuzione del trolley</h3>
	 	Il segnale che si occupa di bloccare/riprendere l'esecuzione del trolley potrebbe essere gestito
	 	da diversi componenti:
	 	
	 	<h4>Transport Trolley</h4>
	 	Potrebbe essere il componente di più alto livello a gestire questi messaggi, per poi comunicarli
	 	al livello sottostante (Mover). <br>
	 	Con questa soluzione possiamo fornire all'handler un'informaizone sul proprio stato, che potrebbe 
	 	esserre utilizzata per comunicare con il resto del sistema.
	 	
	 	<h4> Transport Trolley mover</h4>
	 	Potrebbe essere il mover a gestire questi segnali, essendo i comandi di blocco/ripresa comandi 
	 	relativi all'effettivo movimento del robot (e quindi di basso livello).
	 	<br>
	 	Tutto avverebbe in maniera completamente trasparente rispetto ai componenti di alto livello.
	 	Essendo che, al momento, il componente Handler del trolley si occupa solamente delle azioni
	 	di alto livello di quest'ultimo, questa soluzioni risulta ragionevole.
	 	
	 	<h4> BasicRobot </h4>
	 	Si potrebbe apportare una modifica al basicRobot per poter comunicare direttamente con esso. <br>
	 	Essendo che si è deciso di utilizzare il basicRobot per facilitare lo sviluppo del sistema (essendo
	 	esso un componente già sviluppato dalla software house) si sconsiglia questa soluzione.
	 	
	 	<h3> Soluzione Proposta </h3>
		Tabella nella quale vengono elencati i messaggi aggiunti in questa fase: <br><br>
		 <table style="width:80%">
			<thead>
			  <tr>
				<th>Messaggio</th>
				<th>Tipo </th>
				<th> Descrizione </th>
			  </tr>
			</thead>
			<tbody>
			  <tr>
				<td> blink </td>
				<td> Dispatch</td>
				<td> Messaggio inviato dal LedController per segnalare al led di eseguire blink</td>
			  </tr>
			  <tr>
				<td> turnOn </td>
				<td> Dispatch</td>
				<td> Messaggio inviato dal LedController per segnalare al led di accendersi </td>
			  </tr>
			  <tr>
				<td> sonardata </td>
				<td> Event</td>
				<td> Evento inviato dal sonar per segnalare la distanza rilevata </td>
			  </tr>
			  <tr>
				<td> stop </td>
				<td> Dispatch </td>
				<td> Messaggio inviato dall'alarm emitter al transporttrolley_mover nel caso il sonar rilevi una distanza minore di DLIMIT</td>
			  </tr>
			  <tr>
				<td> resume </td>
				<td> Dispatch </td>
				<td> Messaggio inviato dall'alarm emitter al transporttrolley_mover nel caso il sonar rilevi una distanza maggiore di DLIMIT e il trolley sia in stato di stop</td>
			  </tr>

			</tbody>
			</table>

		<br>
		<br>
		Nella soluzione proposta si è cercato di mantenere separato i componenti sul raspberry dal resto del sistema. <br>
		Per quanto riguarda i cambiamenti ai componenti già realizzata si ha:
		<ul>
			<li>
				WasteService: aggiorna attraverso CoAP la posizione del trolley all'interno della stanza.
			</li>
			<li>
				TransportTrolley: aggiorna attraverso CoAP lo stato nella quale si trova, che viene successivamente utilizzato dal LedController per comandare il led.
			</li>
		</ul>
		Inoltre è stato aggiunto nel contesto del transport trolley un nuovo componente: alarmemitter, che si occupa di analizzare gli eventi emessi dal sonar
		e nel caso la distanza sia minore di DLIMIT invia un messaggio di dispatch al transporttrolley_mover per poter stoppare la sua esecuzione.


		<h3> Modello analisi del Problema Sprint2 </h3>
	
		<a href="./qak/Sprint2Problem.qakt" >Modello analisi del problema rasp</a>
		<br>
		<a href="./qak/WasteService.qakt" >TransportTrolley</a>
		<br>
		<a href="./qak/TransportTrolley.qakt" >WasteService</a>
		<br>


		<h3> Architettura logica </h3>
		<img src="img/wasteserviceSprint2Problem.png" alt="img"> <br>
	 
	 	
	 	
	 </div>
	
	<h2>Test plans</h2> 
	
	<div class="remark">
		Di seguito vengono riportati i test per assicurarsi il corretto funzionamento dei nuovi componenti
		del sistema.<br>
		Per effettuare il testing del sistema, avviare attraverso docker l'immagine dello sprint1 del sistema.
	
		<br><br>
	
		<b>Test Led</b><br>
		<a href="./test/ProblemAnalysis/TestLed.java" >Test led</a> <br>
		
		<ul>
			<li>
				TestLed: il test va a verificare il corretto comportamento del led, in base allo stato 
				in cui si trova il trolley. <br>
				Viene inviata una richiesta di un truck e si controlla che il led si trovi nello stato giusto in base allo posizione e allo stato del trolley.
			</li>
			<li>
				TestLedStop: Si invia una richiesta da parte di deposito e dopo un tempo random si invia un messaggio di stop e si verifica che il trolley sia 
				in stato di stop e che il led sia acceso.<br>
				Dopo un tempo T viene inviato il messaggio di resume e si controlla che il led e il trolley abbiano cambiato il loro stato.
			</li>
		</ul>
		
		<br><br>
		
		<b>Test Sonar</b><br>
		<a href="./test/ProblemAnalysis/TestSonar.java" >Test sonar</a> <br>
		
		<ul>
			<li>
				TestSonar: il test va a verificare che nel caso in cui il sonar osservi una distanza minore di DLIMIT, il trolley vada in stato di STOP.
			</li>
		</ul>
		
		<br><br>
		
		
	</div>
	
	
	
	<h2>Project</h2> 
	<div class="remark">
	<h3> Waste Service </h3>
	Il primo compito della progettazione sarà quello di separare i vari compiti attribuiti al WasteService in Analisi del problema.
	
	<ul>
		<li>
			Handler: una entità principale che si occupa di ricevere le richieste di deposito da parte del WasteTruck ed inizia
			la procedura di deposito
		</li>
		
		<li>
			Core: componente che si occupa di gestire il requisito Core definito in analisi dei requisiti. In particolare, 
			essendo che il trolley viene trattato come un semplice attuatore, la parte Core del waste Service si occuperà
			di segnalare tutti i movimenti che il trolley deve fare e di tenere traccia della sua posizione.
		</li>
		
		<li>
			Storage: per scopo prototipale, in analisi del problema, il compito dello storage è stato fornito al WasteService
			cablando i dati all'interno di esso. In progettazione verrà aggiunto un nuovo componente, che interagirà con il 
			WasteService, che si occuperà proprio di gestire i pesi nei vari container.
		</li>
		
		<li>
			Un file di configurazione per quanto riguarda i parametri (come la posizione dei container).
		</li>
	
	</ul>
	
	
	<h4> WasteServiceHandler </h4>
	La parte Handler del wasteService viene realizzato come un'applicazione web realizzata tramite Spring per facilitarne lo sviluppo.
	<br>
	Il primo compito che l'handler deve eseguire è quello di interagire con il WasteTruck, realizzandolo, a questo punto, come
	un vero e proprio "alieno" e non un attore come veniva mostrato in analisi per scopi prototipali.
	Verrà realizzata un interfaccia Web per il WasteTruck per comunicare con il WasteServiceHandler attraverso
	API Rest.
	<br>
	Successivamente l'handler dovrà interagire con il nuovo componente introdotto: StorageManager, per potersi
	assicurare che ci sia lo spazio nei container per poter depositare i materiali.
	Per fare questo, non essendo un attore il componente handler, agirà a sua volta da alieno nei confronti
	del contesto QAK.
	In seguito alla risposta dello storageManager, l'handler andrà ad inviare loadaccepted o loadrejected
	al wasteTruck.
	<br>
	Infine, l'applicazione Web andrà ad interagire con il componente Core del WasteService per poter 
	iniziare la vera e proprio azione di pickup/deposito. Per fare questo si necessita di introdurre
	un nuovo scambio di informazioni e quindi un nuovo messaggio.
	Dato che l'handler necessita di una risposta, per sapere quando liberare il WasteTruck dall'area di deposito,
	questa comunicazione verrà realizzata come una request/reply. 
	<br>
	
	<pre><key2>Request</key2> startDeposit : startDeposit(_) <br><key2>Reply</key2> pickedUp : pickedUp(_)</pre>
	
	<br>
	Quando l'handler deve avviare la fase di deposito invia il messaggio di startDeposito al componente
	Core e quando il trolley ha effettivamente ritirato i materiali da Indoor il componente Core invia
	la reply pickedUp all'handler, che si occuperà di inviare il messaggio mostrato in analisi del problema:
	"LeaveIndoor" per poter segnalare al truck di liberare l'area di scarico, in modo da poter accettare
	nuove richieste.
	
	
	
	<h4> WasteServiceCore </h4>
	Il componente Core del WasteService si occuperà di gestire la logica di business dell'applicazione e
	inviare i vari messaggi per poter comandare il transportTrolley come è stato mostrato con il WasteService
	nel prototipo dell'analisi del problema.
	<br>
	Quando il Core riceverà il messaggio di startDeposit da parte dell'handler, si avviano le operazioni
	necessarie per poter eseguire tutte le azioni per arrivare al deposito dei materiali all'interno del 
	container corretto.
	
	<br>
	Al termine dell'azione di pickup da parte del Trolley, il Core invierà la reply introdotta 
	precedentemente: "pickedUp" all'handler, in modo da poter liberare l'area di deposito.
	
	
	<h4> StorageManager </h4>
	Il componente StorageManager si occuperà di gestire il peso corrente nei container e di valutare se sia 
	possibile depositare il carico specificato da un WasteTruck che si trova nell'area di scarico.
	<br>
	Ogni volta che il peso verrà modificato il compenente utilizzerà il protocollo CoAP per segnalare la 
	modifica. Questo facilita sia la fase di testing per verificare che il sistema funzioni correttamente, sia
	permette a componenti interessati a questi cambiamenti di poterli "ascoltare".
	
	<br>
	Per poter realizzare queste nuove comunicazioni servono nuovi messaggi.
	<pre><key2>Request</key2> storeRequest : storeRequest(MAT, QNT) <br><key2>Reply</key2> storeRequestReply : sotreRequestReply(ANS)</pre>
	
	<br>
	Il componente Handler del WasteService utilizzerà il messaggio di request "storeRequest" per poter
	chiedere allo StorageManager se sia possibile depositare il materiale MAT con quantità QNT, lo 
	StorageManager, attraverso la reply "storeRequestReply", segnalerà se sia possibile o meno farlo.
	
	<br>
	Per poter aggiornare i pesi, in seguito alla deposit da parte del trolley, si introduce un evento,
	inviato dal WasteServiceCore, per segnalare l'avvenuto deposito. Quando lo StorageManager riceve questo
	evento si occuperà di aggiornare i pesi ed inviare un messaggio tramite CoAP per comunicare il nuovo
	valore del peso dei container.
	
	<pre><key2>updateResource</key2>[# "glass($CurrentGlassWeight), plastic($CurrentPlasticWeight)" #]</pre>
	
	<h4> File di configurazione</h4>
	Infine, viene introdotto un file di configurazione nella quale vengono inseriti tutti i valori 
	preimpostati in modo da non doverli cablare nel codice.
	
	
	<pre>
		{
		    <key4>"LOCATION"</key4>: {
		        <key4>"HOME"</key4>: [0, 0],
		        <key4>"INDOOR"</key4>: [16, 0],
		        <key4>"PLASTICBOX"</key4>: [16, 19],
		        <key4>"GLASSBOX"</key4>: [0, 19]
		    },
		    <key4>"MAXPB"</key4>: 500,
		    <key4>"MAXGB"</key4>: 500,
		    <key4>"DLIMIT"</key4>: 40
		}
		</pre>
	
	
	<h3> Transport Trolley </h3>
	Seguendo le indicazioni dell'analisi del problema si è voluto realizzare il transportTrolley come
	un attuatore. <br>
	Tuttavia si ha una parte di logica di business che non può essere eliminata dal trolley, in particolare,
	la parte nella quale si necessita di fare il pickup ed il deposito dei materiali.
	<br>
	In progettazione si vogliono separare queste due parti del transportTrolley:
	
	<ul>
		<li>
			TransportTrolleyHandler: Un primo componente che si occupi proprio di fare queste operazioni e di fare da "manager"
			delle richieste che arrivano da parte del WasteService. In particolare, in analisi
			era stato evidenziata la necessità di un componente che trovasse un percorso verso la destinazione
			inviata dal WasteService. <br>
			Questo componente si occuperà, prima di tutto, di chiedere il percorso al componente mostrato 
			in analisi "PathFinder" e successivamente di inviare il percorso al componente che si occupa
			di muovere il trolley lungo tale percorso.
	
		</li>
		<li>
			TransportTrolleyMover: Un secondo componente che si occupi effettivamente dei movimenti da eseguire per raggiungere
			la destinazione specificata. In particolare, si è pensato di utilizzare il BasicRobot e il 
			PathExec (componenti già realizzati dalla software house per poter effettivamente muovere
			il robot).
			BasicRobot permette di implementare il movimento del robot in modo indipendente dalla tecnologia
			utilizzata, il che lo rende un componente fondamentale in fase di testing e sviluppo.
		</li>
	</ul>
	
	
	
	
	</div>
	
	<h2>Testing</h2> 
	 
	
	<h2>Deployment</h2> 
	
	 
	<h2>Maintenance</h2> 
	 
	<!-- USEFUL
	<table style="width:100%" border="1">
	<tr>
	<td style="width:50%">
	</td>
	<td></td>
	</tr>
	</table>
	-->
		      	
	<br/><br/> 	

	
	<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
	By Thomas Ambrogini email: thomas.ambrogini@studio.unibo.it  
	<img src="./img/ThomasAmbrogini.jpg" alt="mbot" width="15%" height="15%">
	</div> 
</body>
</html>