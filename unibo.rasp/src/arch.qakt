System rasp
 
Dispatch cmd       	: cmd(MOVE)      
Dispatch end       	: end(ARG)   
  
Request step       : step( TIME )	
Reply   stepdone   : stepdone(V)  
Reply   stepfail   : stepfail(DURATION, CAUSE)

Dispatch obstacle  : obstacle( ARG ) 	//generated by distancefilter
Event   info       : info( ARG ) 	    //for external components, not coap-observed

Request  startDeposit   : startDeposit( TYPE )
Reply    leaveIndoor    : leaveIndoor(_)

Request  pickup         : pickup( ARG )
Reply    pickupDone     : pickupDone( ARG )

Request  deposit        : deposit( ARG )
Reply    depositDone    : depositDone( ARG )

Request  moveToDestination  : info( X_DESTINATION, Y_DESTINATION )
Reply    destinationReached : destinationReached( ARG )

//STORAGE MANAGER
 
Request  storageAsk        : storageAsk(MAT)
Reply 	 storageAmount     : storageAmount(MAT, QNT)

Request  storeRequest      : storeRequest(MAT, QNT) 
Reply    storeRequestReply : storeRequestReply(ANS)

Dispatch updateWeights     : updateWeights(_)


//LED 
Dispatch blink   : blink(_)
Dispatch turnon  : turnon(_)
Dispatch turnoff : turnoff(_)


//SONAR
Dispatch sonaractivate   : info(ARG)
Dispatch sonardeactivate : info(ARG)
Event    sonar           : distance( V )  
Event    sonardata       : distance( V )

Dispatch coapUpdate : coapUpdate(RESOURCE, VALUE)


Request  pickup         	: pickup( ARG )
Reply    pickupDone     	: pickupDone( ARG )
Request  deposit        	: deposit( ARG )
Reply    depositDone    	: depositDone( ARG )
Request  moveToDestination  : info( X_DESTINATION, Y_DESTINATION )
Reply    destinationReached : destinationReached( ARG )

Request  findPath           : findPath( X_DESTINATION, Y_DESTINATION )
Reply    path               : path( PATH )

Request  dopath             : dopath( PATH  )
Reply 	 dopathdone     : dopathdone( ARG ) 
Reply 	 dopathfail     : dopathfail( ARG )

//SONAR
Dispatch stop  	 	: stop(_)
Dispatch resume 	: resume(_)
Event 	 alarm 		: alarm(STOP)

Context ctx_basicrobot       ip [ host="robot" port=8020 ]
Context ctx_wasteservice     ip [ host="wasteservice" port=8049 ]
Context ctx_transporttrolley ip [ host="transporttrolley" port=8051 ]
Context ctx_rasp 			 ip [ host="localhost" port=8056 ]

//DATA SOURCES
CodedQActor sonarsimulator  context ctx_rasp className "sonarSimulator"  
CodedQActor sonardatasource context ctx_rasp className "sonarHCSR04Support2021"
CodedQActor datacleaner    	context ctx_rasp className "dataCleaner"

CodedQActor ledsimulator    context ctx_rasp className "ledSimulator"
CodedQActor ledconcrete     context ctx_rasp className "ledConcrete"


QActor basicrobot context ctx_basicrobot{
	[#
	  var StepTime      = 0L
	  var StartTime     = 0L     
	  var Duration      = 0L  
	  var RobotType     = "" 
	  var CurrentMove   = "unkknown"
	#]  
	
 	State s0 initial { 	      
 		discardMsg Off  //WE want receive any msg
 		//[# unibo.comm22.utils.CommSystemConfig.tracing = false #]  //tracing at unibo.comm22 level
		println("basicrobot | START")
		delay 5000
 		qrun unibo.robot.robotSupport.create(myself,"basicrobotConfig.json")	
 		[# RobotType = unibo.robot.robotSupport.robotKind #]
 		delay 1000  //give to the realsonar the time to start
        if[# RobotType != "virtual" #]{
        	[# var robotsonar = context!!.hasActor("realsonar")  
        	   if(robotsonar != null) unibo.robot.robotSupport.createSonarPipe(robotsonar) 
        	#] 
  		}//The Virtual robot sonar is created in virtualrobotSupport2021
 
  		run unibo.robot.robotSupport.move( "a" )    //synch
 		run unibo.robot.robotSupport.move( "d" )	//synch
    		//run unibo.robot.robotSupport.move( "w" )    //asynch
 		updateResource [# "basicrobot(start)" #]
 	} 
	Goto work
	
	State work{ 
		println("basicrobot  | waiting .................. ")  
	} 
	Transition t1   whenMsg     cmd       -> execcmd
					whenRequest step      -> doStep			 
					whenMsg    obstacle   -> handleObstacle  //in virtualrobot caused by the move w/s
					//whenEvent sonar       -> handleSonar
				  	whenMsg     end       -> endwork			  
	
	State execcmd{
		printCurrentMessage
		onMsg( cmd : cmd(MOVE) ){
  			//activate the motors  
  			[# CurrentMove = payloadArg(0) #]
			run unibo.robot.robotSupport.move( payloadArg(0 ) )
			updateResource [# "moveactivated(${payloadArg(0)})" #]
		}
	 }
	 Goto work   
	 
	State handleObstacle{
		//println("basicrobotttttttttt | handleObstacle ${CurrentMove}")	
		//run unibo.robot.robotSupport.move( "h" ) //non importa 
		//printCurrentMessage
		updateResource [# "obstacle(${CurrentMove})" #]
		//JUNE22: behavior embedded in VirtualrobotSupport2021
		/* 
		if[# CurrentMove == "w" #]{
		//back to avoid emission of obstacle again if real robot moving forward !!!
		//if[# RobotType != "virtual" #]{	
			run unibo.robot.robotSupport.move( "s" )
			delay 100 
			run unibo.robot.robotSupport.move( "h" ) 
 		}*/
 		//emit info : info( obstacledoing(w) )
	}
	Goto work  
 
	State handleSonar{
		printCurrentMessage
	}
	Goto work
		
   	State doStep{ 
 		printCurrentMessage  
		onMsg( step : step( T ) ){  
			[#	StepTime     = payloadArg(0).toLong()  	#]    
			updateResource [# "step(${StepTime})" #]
  		}  
        memoCurrentTime StartTime  
        println("basicrobot | doStep StepTime =$StepTime  ")        
        run unibo.robot.robotSupport.move( "w" )  //moves a real robot forever !!!
	}  
	Transition t0 
		whenTimeVar StepTime  -> stepDone  	
 		whenMsg  obstacle     -> stepFail		
    	 
	State stepDone{   
 		run unibo.robot.robotSupport.move( "h" )  //stop the (real) robot
		//printCurrentMessage
		updateResource [# "stepDone($StepTime)" #]
   		//emit info : info( stepdone($StepTime) )
   		replyTo step with stepdone : stepdone(ok)
		println("basicrobot | stepDone reply done")
  	}
	Goto work  
 
	State stepFail{  	 	
		run unibo.robot.robotSupport.move( "h" )  //stop the (real) robot
		//printCurrentMessage
		setDuration Duration from StartTime
		[# var TunedDuration   =  ((Duration * 0.80)).toLong()   #]
		println("basicrobot | stepFail duration=$Duration  TunedDuration=$TunedDuration")
			run unibo.robot.robotSupport.move( "s" )
			delayVar TunedDuration 
			run unibo.robot.robotSupport.move( "h" ) 
 		updateResource [# "stepFail($Duration)" #] 
 		replyTo step with stepfail : stepfail($Duration, obst)
    }
	Goto work
	
	State endwork{ 
		updateResource [# "basicrobot(end)" #]	 		
 		terminate 1
	}   
 
}



QActor pathexec context ctx_basicrobot{ 
[# var CurMoveTodo = ""    //Upcase, since var to be used in guards
   var StepTime    = "300"
   var PathTodo    = ""
#]
	State s0 initial{  	
		//printCurrentMessage
		[#  CurMoveTodo = "" 
			StepTime = unibo.robot.robotSupport.readStepTime() //stepTimeConfig.json
		#]
		updateResource [# "pathexecsteptime($StepTime)" #]
		println("pathexec ready. StepTime=$StepTime") 
	}	
	Transition t0 whenRequest dopath -> doThePath
  	
	State doThePath{
		printCurrentMessage 
		//[# prinln( currentMsg ) #]
		onMsg ( dopath : dopath( PATH )){
			[# PathTodo = payloadArg(0) #]
		    updateResource [# "pathexecdopath($PathTodo)" #]
			run pathut.setPath( PathTodo )  //se payloadArg fallisce non da eccezione! (ma non fa nulla)
		}		 
		println("pathexec pathTodo = ${pathut.getPathTodo()}") 
 	}
	Goto nextMove    
	
	
	State nextMove{ 
		[# CurMoveTodo = pathut.nextMove() #]	
		//println("pathexec curMoveTodo=$CurMoveTodo" )
	} 
	Goto endWorkOk if [# CurMoveTodo.length == 0 #] else doMove
	
	State doMove{
		//printCurrentMessage
// 		delay 300  //avoid too fast ...
 	}
	Goto doMoveW if [# CurMoveTodo == "w" #] else doMoveTurn
	
	State doMoveTurn{
		//printCurrentMessage
		updateResource [# "pathexecdoturn($CurMoveTodo)" #]
		forward basicrobot -m cmd : cmd($CurMoveTodo) //asynch !!!		
	}
	Transition t0 whenTime 300 ->  nextMove  //wait for move done ...
  
 	State doMoveW{
		//printCurrentMessage
		updateResource [# "pathexecdostep($CurMoveTodo)" #]
		request basicrobot -m step : step( $StepTime )
	}	
	Transition t0 whenEvent alarm     -> endWorkKo
 				  whenReply stepdone  -> nextMove  
	              whenReply stepfail  -> endWorkKo                       
	              
	State endWorkOk{
		//printCurrentMessage
		println("endWorkOk: PATH DONE - BYE")
		updateResource [# "path $PathTodo done" #]	
		replyTo dopath with dopathdone : dopathdone( ok )
	}
	Goto s0 
 
	State endWorkKo{
		printCurrentMessage
		[# var PathStillTodo = pathut.getPathTodo() #]
		updateResource [# "pathstilltodo($PathStillTodo)" #]	
		println("PATH FAILURE - SORRY. PathStillTodo=$PathStillTodo")
		replyTo dopath with dopathfail : dopathfail( $PathStillTodo )
	}	
	Goto s0


} 


QActor transporttrolley context ctx_transporttrolley {
	
	State s0 initial {
		printCurrentMessage	
	}
	
	Transition t0 whenRequest moveToDestination -> move
	
	State move {
		printCurrentMessage
		updateResource [# "work" #]
		
		onMsg( moveToDestination : info( X_DESTINATION, Y_DESTINATION )) {
			
			request transporttrolley_mover -m findPath : findPath( $payloadArg(0), $payloadArg(1) )
		}
	}
	
	Transition t1 	whenReply dopathdone -> destinationReached
	
	State destinationReached {
		printCurrentMessage
		replyTo moveToDestination with destinationReached : destinationReached(ok)
	}
	
	Transition t2 whenRequest pickup -> handle_pickup
				  whenRequest deposit -> handle_deposit
				  whenRequest moveToDestination -> move
	
	
	State handle_pickup {
		printCurrentMessage
		delay 5000
		replyTo pickup with pickupDone : pickupDone(true)
	}
	
	Transition t3 whenRequest moveToDestination -> move
	
	
	State handle_deposit {
		printCurrentMessage
		delay 5000
		replyTo deposit with depositDone : depositDone(true)
	}
	
	Transition t4 	whenRequest moveToDestination -> move

}



QActor transporttrolley_mover context ctx_transporttrolley { 
	[#
		var RemainingPath = ""
	#] 
	
	State s0 initial {
		
		printCurrentMessage
		[# 
			unibo.kotlin.planner22Util.initAI();
			unibo.kotlin.planner22Util.loadRoomMap("mapRoomEmpty");
			unibo.kotlin.planner22Util.showMap();
			unibo.kotlin.planner22Util.showCurrentRobotState();
		#]	
	}
	
	Goto idle
	
	State idle {
		printCurrentMessage
		updateResource [# "trolleyState(idle)" #]
		
	}
	
	Transition t0 	whenMsg     stop     -> stopped
					whenRequest findPath -> findThePath
	
	State findThePath {
		updateResource [# "trolleyState(work)" #]
		[#
			var MovesToDo = ""	
		#]
		printCurrentMessage

		onMsg( findPath : findPath( X_DESTINATION, Y_DESTINATION )) {
			[#
				val X_Destination = payloadArg(0)
				val Y_Destination = payloadArg(1)
				unibo.kotlin.planner22Util.planForGoal( X_Destination, Y_Destination )
				MovesToDo = unibo.kotlin.planner22Util.getActions().joinToString("")
				pathut.setPath(MovesToDo)
				pathut.updateMap()
			#] 
		}

		println(MovesToDo)
		request pathexec -m dopath : dopath($MovesToDo)
			
	}
	
	Transition t1 	whenMsg   stop       -> savepath
					whenReply dopathdone -> pathDone
					whenReply dopathfail -> handle_resume
					
	
	State pathDone {
		printCurrentMessage
		
		replyTo findPath with dopathdone : dopathdone(ok)
	}
	
//	Transition t2 	whenMsg     stop     -> stopped
//					whenRequest findPath -> findThePath

	Goto idle
	
	
	State savepath {
		printCurrentMessage
		onMsg(dopathfail: dopathfail(PATH)){
			[#
				RemainingPath = payloadArg(0)
			#]	
		}
		emit alarm : alarm(STOP)
		println("TROLLEY | SAVE PATH: $RemainingPath")
	}
	
	Goto stopped
					
	State stopped {
		printCurrentMessage
		println("TROLLEY | STOPPED")
		updateResource [# "trolleyState(stopped)" #]
	}
	
	Transition t7 whenMsg resume -> handle_resume
	
	State handle_resume {
		printCurrentMessage
		updateResource [# "trolleyState(work)" #]
		
		onMsg(resume : resume(STATE)){
			
			request pathexec -m dopath : dopath($RemainingPath) 
			
			[# RemainingPath = "" #]
		}

		
		onMsg (dopathfail   : dopathfail( ARG )) {
			[#
				var RemainingPath = payloadArg(0)
			#]
			if [# RemainingPath.length == 1 || RemainingPath.length == 0#]{
				[# RemainingPath = "" #]
				request pathexec -m dopath : dopath($RemainingPath) 
			}
			else{
				request pathexec -m dopath : dopath($RemainingPath) 
			}
		}

	}
	
	Transition t2 whenTime 5000 -> idle
				  whenMsg stop -> stopped
				  whenReply dopathdone -> pathDone
				  whenReply dopathfail -> handle_resume


}

QActor alarmemitter context ctx_transporttrolley {	
	
	[# 
		var DLIMIT = 20
		var stopped = "False"
	#]
	
	State s0 initial {
		printCurrentMessage
	}
	Transition t0 whenEvent sonardata -> handle_sonardata
	
	State handle_sonardata {
		printCurrentMessage
		
		onMsg ( sonardata : distance (DIST) ) {
			[# val dLimit = DLIMIT #]
			[# val dist = payloadArg(0).toFloat() #]

			if [# dist <= dLimit && stopped.equals("False")#] {
				println("STOP")
				[# stopped = "True" #]
				forward transporttrolley_mover -m stop : stop(STOP)
			}
			if [# dist > dLimit && stopped.equals("True") #] {
				println("RESUME")
				[# stopped = "False" #]
				forward transporttrolley_mover -m resume : resume(RESUME)
			}
		}
	}
	
	Goto s0
	
}
 

QActor storage_manager context ctx_wasteservice {
	[#
		val Utility = utility.storage_manager.StorageManagerUtility()	
	#]
	
	State s0 initial {
		printCurrentMessage
	}
	
	Transition t0 whenRequest storeRequest  -> handleRequest
				  whenRequest storageAsk    -> handleAsk
				  whenMsg     updateWeights -> handleUpdate
	
	State handleRequest {
		printCurrentMessage
		
		onMsg (storeRequest : storeRequest(MAT, QNT)) {
			if [# Utility.checkDeposit(payloadArg(0), payloadArg(1).toDouble()) #] {
				replyTo storeRequest with storeRequestReply : storeRequestReply(accepted)
			}
			else {
				replyTo storeRequest with storeRequestReply : storeRequestReply(rejected)
			}
		}
	}
	
	Goto s0
	
	State handleAsk {
		printCurrentMessage
		onMsg (storageAsk : storageAsk(MAT) ) {
			[# var SpaceLeft = Utility.getWeight(payloadArg(0)) #]
			replyTo storageAsk with storageAmount : storageAt($payloadArg(0), $SpaceLeft)
		}
	}
	
	Goto s0
	
	State handleUpdate {
		printCurrentMessage
		
		[# 
			Utility.deposit()
			val CurrentGlass = Utility.getWeight("Glass")
			val CurrentPlastic = Utility.getWeight("Plastic")

		#]
		
		updateResource [# "glass($CurrentGlass), plastic($CurrentPlastic)" #]
		
	}
	
	Goto s0
	
}


QActor wasteservice context ctx_wasteservice {
	[#
		var Type                 = ""
	#]
	
	State home initial {
		printCurrentMessage
		updateResource [# "trolleyPosition(home)" #]
	}
	
	Transition t0 whenRequest startDeposit -> moveTrolleyIndoor

	State moveTrolleyIndoor {
		printCurrentMessage
		
		[#
			val X_Destination = positionUt.getCordX("indoor")
			val Y_Destination = positionUt.getCordY("indoor")
		#]
		
		onMsg( startDeposit : startDeposit(TYPE) ) {
			[#
				Type = payloadArg(0)				
			#]	
		}
		
		request transporttrolley -m moveToDestination : info( $X_Destination, $Y_Destination )
	}
	
	Transition t2 whenReply destinationReached -> handlepickup
	
	State handlepickup {
		printCurrentMessage
		updateResource [# "trolleyPosition(indoor)" #]
	
		request transporttrolley -m pickup : pickup(true)
	}
	
	Transition t11 whenReply pickupDone -> handle_pickupDone
	
	State handle_pickupDone {
		printCurrentMessage
		
		replyTo startDeposit with leaveIndoor : leaveIndoor(leave)
		
	}
 	
	Goto  moveTrolleyContainer
	
	State moveTrolleyContainer {
		printCurrentMessage
		
		[#
			val X_Destination = positionUt.getCordX(Type)
			val Y_Destination = positionUt.getCordY(Type)
		#]
		
			
		request transporttrolley -m moveToDestination : info( $X_Destination, $Y_Destination )
		
		
	}
	
	Transition t4 whenReply destinationReached -> handleDeposit
	
	State handleDeposit {
		printCurrentMessage
		updateResource [# "trolleyPosition($Type)" #]
		
		request transporttrolley -m deposit : deposit(true)
		
	}
	
	Transition t11 whenReply depositDone -> handle_depositDone
	
	State handle_depositDone {
		printCurrentMessage
		forward storage_manager -m updateWeights : updateWeights(_)
	}
	

	Transition t5 	whenTime 10 -> moveTrolleyHome
					whenRequest startDeposit -> moveTrolleyIndoor
		

					
	State moveTrolleyHome {
		printCurrentMessage
		
		[#
			val X_Destination = positionUt.getCordX("home")
			val Y_Destination = positionUt.getCordY("home")
		#]
		
		request transporttrolley -m moveToDestination : info( $X_Destination, $Y_Destination )
	}
	
	Transition t12 whenReply destinationReached -> home
						
	
}

QActor led context ctx_rasp {
	[#
	   val simulate       = true
	   val ledActorName = "led"
	#]
	
	State start initial {
		run  ledConfig.configureTheLed(simulate, ledActorName)
		updateResource [# "ledState(off)" #]
	}
	
	Goto listen
	
	State listen {
		printCurrentMessage
	}
	Transition t0 whenMsg turnon  -> handle_on
				  whenMsg turnoff -> handle_off
				  whenMsg blink   -> handle_blink_on
	
	State handle_on {
		printCurrentMessage
		
		if [# `it.unibo`.radarSystem22.domain.utils.DomainSystemConfig.simulation #] {
			forward ledsimulator -m turnon :turnon(on)
		} else {
			forward ledconcrete -m turnon : turnon(on)
		}
		updateResource [# "ledState(on)" #]
	}
	Goto listen
	
	State handle_off {
		printCurrentMessage
		
		if [# `it.unibo`.radarSystem22.domain.utils.DomainSystemConfig.simulation #] {
			forward ledsimulator -m turnoff :turnoff(on)
		} else {
			forward ledconcrete -m turnoff : turnoff(on)
		}
		updateResource [# "ledState(off)" #]
	}
	Goto listen
	
	State handle_blink_on {
		printCurrentMessage
		
		if [# `it.unibo`.radarSystem22.domain.utils.DomainSystemConfig.simulation #] {
			forward ledsimulator -m turnon : turnon(blink)
		} else {
			forward ledconcrete -m turnon : turnon(blink)
		}
		updateResource [# "ledState(blink)" #]
	}
	
	Transition t0 whenTime 500 -> handle_blink_off 
				  whenMsg  turnon -> handle_on
				  whenMsg  turnoff-> handle_off
	
	State handle_blink_off {
		printCurrentMessage
		
		if [# `it.unibo`.radarSystem22.domain.utils.DomainSystemConfig.simulation #] {
			forward ledsimulator -m turnoff :turnoff(blink)
		} else {
			forward ledconcrete -m turnoff : turnoff(blink)
		}
		updateResource [# "ledState(blink)" #]
		
	}
	
	Transition t0 whenTime 500 -> handle_blink_on
				  whenMsg  turnon -> handle_on
				  whenMsg  turnoff-> handle_off
					
					
}


QActor sonarqak22 context ctx_rasp {	
	[# 
	   val simulate       = true
	   val sonarActorName = "sonarqak22"
	#]
	
	
	State s0 initial {
		//printCurrentMessage
		run  sonarConfig.configureTheSonar(simulate, sonarActorName)
		 
		//ASSUMPTION: the sonar subsystem emits the event sonar:distance(V)
	}
	
	Goto idle
	
	State idle {
		
	}
	Transition t0 whenMsg sonaractivate   -> activateTheSonar
			      whenMsg sonardeactivate -> deactivateTheSonar
			      
			      
	State activateTheSonar{
		printCurrentMessage
		if[#  `it.unibo`.radarSystem22.domain.utils.DomainSystemConfig.simulation #]{
			forward sonarsimulator -m sonaractivate : info(ok) 
			//run sonarConfig.activateSonarSimulated() //usingDomain
		}else {
			 forward sonardatasource -m sonaractivate : info(ok)  
		}
	}
	Transition t0  whenEvent sonar           -> handleSonarData  
	               whenMsg 	 sonardeactivate -> deactivateTheSonar
	               
	State deactivateTheSonar{
		printCurrentMessage
	}
	Goto end
	
	State handleSonarData{
  		 printCurrentMessage
  		 onMsg( sonar : distance(D) ){
   		 	[# val D = payloadArg(0) #]  
  		    println("%%%%%%%%%%%%%%%%%%%%%%%%%%% emit %%%%%%%%%%%%%%% ${D}")
  		 	emit sonardata : distance($D) //for the application
  		 	updateResource [# "$D" #]
  		 }
  	}
  	Transition t0 whenEvent sonar -> handleSonarData
   				  whenMsg   sonardeactivate -> deactivateTheSonar
	
	State end{ 
		println("sonarqak22 Deactivated")
	}
	
	Goto idle
	
}
 
QActor ledcontroller context ctx_rasp {
	[#
		var AtHome = true
		var Stopped = false
		var CurrentLedState = "off"
		var State   = ""
	#]
	
	State init initial {
		qrun coapObserverUtil.observe(myself, "transporttrolley:8051", "ctx_transporttrolley/transporttrolley_mover")
		qrun coapObserverUtil.observe(myself, "wasteservice:8049", "ctx_wasteservice/wasteservice")
	}
	Goto observe
	
	State observe {
		printCurrentMessage
	}	
	Transition t0 whenMsg coapUpdate -> handleStatus

 	
	State handleStatus {
		printCurrentMessage
		
		onMsg ( coapUpdate : coapUpdate(RESOURCE, VALUE) ) {
			[# 
				var NextLedState 	= "" 
			#]
			
			println("Led Controller | Received update from ${payloadArg(0)}, is ${payloadArg(1)} ; currently AtHome $AtHome Stopped $Stopped CurrentState $CurrentLedState")
			

			
			if [# payloadArg(0) == "ctx_transporttrolley_transporttrolley_mover" #] {
				
				// trolleyState(work|stopped|idle)
				
				[# 
					State   = PayloadUtils.getTrolleyState(payloadArg(1))
					Stopped = State == "stopped" 
				#]
				
				if [# Stopped #] {
					[# 
						NextLedState = "on"
					#]
				} else {
					if [# State == "work" #] {
						[# NextLedState = "blinking" #]
					} else {
						[# NextLedState = "off" #]
					}
				}
			}
			
			if [# payloadArg(0) == "ctx_wasteservice_wasteservice" #] {
				// trolleyPosition(LOC)
				[# AtHome = PayloadUtils.getTrolleyPosition(payloadArg(1)) == "home" #]
				if [# !Stopped #] {
					if [# AtHome || State == "idle"#] {
						[# NextLedState = "off" #]
					} else {
						if [# State == "work"#] {
							[# NextLedState = "blinking" #]
						}
					}
				}
			}
			
			println("Led Controller | Setting led to $NextLedState")
			
			if [# NextLedState == "on" #] {
				forward led -m turnon : turnon(on)
				
				[#
					CurrentLedState = "on"
				#]	
				
			} else {
				if [# NextLedState == "off" #] {
					forward led -m turnoff : turnoff(off)
					
					[#
						CurrentLedState = "off"
					#]	
					
				}else {
					if [# NextLedState == "blinking" && CurrentLedState != "blinking" #] {
						forward led -m blink : blink(blink)	
						
						[#
							CurrentLedState = "blinking"
						#]	
					}
				}
			}
		}
		
	}
	
	Goto observe
}








