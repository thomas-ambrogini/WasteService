System transporttrolley

mqttBroker "broker.hivemq.com" : 1883 eventTopic "unibo/ambrogini/wasteService"

Request  activate       : activate( TYPE, LOAD ) //activate( PATHINDOOR, PATHCONTAINER, LOAD), activate( XPOS, YPOS, LOAD)
Reply    pickupDone     : pickupDone( ARG )

Dispatch gocontainer    : gocontainer( PATH ) 
//Reply    endDeposit     : endDeposit( TYPE)

Event    loaddeposit    : loaddeposit( TYPE, LOAD )

Request  findPath       : findPath( POSITION ) 
Reply    path           : path( PATH )

Request  dopath         : dopath( PATH  )
Reply 	 dopathdone     : dopathdone( ARG )
Reply 	 dopathfail     : dopathfail( ARG )

Dispatch prova          : prova( ARG )

Context ctxbasicrobot 				  ip [ host="127.0.0.1" port=8020 ]  
Context ctxTransportTrolleyPrototipo1 ip [ host="localhost" port=8051 ]

ExternalQActor pathexec context ctxbasicrobot

QActor transporttrolley context ctxTransportTrolleyPrototipo1 {
	[#
		var CurPosition = ""
		var Destination = ""
		var Container   = ""
		var Load        = 0L
	#]
	
	State s0 initial {
		printCurrentMessage
	}
	
	Transition t0 whenRequest activate -> handleactivate
	
	State handleactivate {
		printCurrentMessage
		
		onMsg( activate : activate( TYPE, LOAD )) {
			[#
				Container = payloadArg(0)
				Load      = payloadArg(1).toLong()
			#]
		}
		
	}
	
	Goto pathForIndoor
	
	State pathForIndoor {
		printCurrentMessage
		request pathfinder -m findPath : findPath(indoor)
	}
	
	Transition t1 whenReply dopathdone -> pickup
	
	State pickup {
		printCurrentMessage
		
		delay 1000
		
		println("Pickup done")
		
		replyTo activate with pickupDone : pickupDone(ok)
	}
	
	Goto pathForContainer
	
	State pathForContainer {
		printCurrentMessage	
		request pathfinder -m findPath : findPath($Container)
	}
	
	Transition t3 whenReply dopathdone -> loaddeposit
	
	State loaddeposit {
		printCurrentMessage
		
		delay 1000
		
		println("Deposit Done")
		
		emit loaddeposit : loaddeposit( $Container, $Load )
	}
	
	Transition t4 	whenTime 5 -> findPathHome
					whenRequest activate -> handleactivate
				  
	State findPathHome {
		printCurrentMessage
		request pathfinder -m findPath : findPath(home)
	}
	
	Transition t5 whenReply dopathdone -> s0
}

QActor pathfinder context ctxTransportTrolleyPrototipo1 { 
	[#
		val XGlass    = "6"
		val YGlass 	  = "4"
		val XPlastic  = "5"
		val YPlastic  = "0"
		val XIndoor   = "1"
		val YIndoor   = "4"
		val XHome     = "0"
		val YHome     = "0"
		var Position  = ""
	
	#]
	
	State s0 initial {
		printCurrentMessage
		[# 
			unibo.kotlin.planner22Util.initAI();
			unibo.kotlin.planner22Util.loadRoomMap("mapRoomEmpty");
			unibo.kotlin.planner22Util.showMap();
			unibo.kotlin.planner22Util.showCurrentRobotState();
		#]	
	}
	
	Transition t0 whenRequest findPath -> findThePath
	
	State findThePath {
		printCurrentMessage
		onMsg( findPath : findPath( POSITION )) {
			[#
				Position = payloadArg(0)
			#]
		}
		
		[#
			unibo.kotlin.planner22Util.showCurrentRobotState();
			var MovesToDo : String
		#]
		
		if [# Position == "glass" #] {
			[#
				unibo.kotlin.planner22Util.planForGoal( XGlass, YGlass )
				MovesToDo = unibo.kotlin.planner22Util.getActions().joinToString("")
			#]
		}else {
			if[# Position == "plastic"#] {
				[#
					unibo.kotlin.planner22Util.planForGoal( XPlastic, YPlastic )
					MovesToDo = unibo.kotlin.planner22Util.getActions().joinToString("")
				#]
			} else {
				if [# Position == "indoor" #] {
					[#
						unibo.kotlin.planner22Util.planForGoal( XIndoor, YIndoor )
						MovesToDo = unibo.kotlin.planner22Util.getActions().joinToString("")
					#]
				} else {
					[#
						unibo.kotlin.planner22Util.planForGoal( XHome, YHome )
						MovesToDo = unibo.kotlin.planner22Util.getActions().joinToString("")
					#]
				}
			}
		}
		
		[#
			pathut.setPath(MovesToDo)
			pathut.updateMap()
		#] 
		

		println(MovesToDo)
		request pathexec -m dopath : dopath($MovesToDo)
			
	}
	
	Transition t1 	whenReply dopathdone -> pathDone
					whenReply dopathfail -> pathFail
					
	
	State pathDone {
		printCurrentMessage
		
		replyTo findPath with dopathdone : dopathdone(ok)
	}
	
	Transition t2 whenRequest findPath -> findThePath
	
	State pathFail {
		printCurrentMessage
		println("PATH FAILED")
	}

}


/* 
QActor prova context ctxTransportTrolleyPrototipo1 {
	State s0 initial {
		printCurrentMessage
		
		request transporttrolley -m activate : activate(glass, 10)
		
		
	}
	
	Transition t0 whenReply pickupDone -> again
	
	State again {
		printCurrentMessage
		delay 10000
		request transporttrolley -m activate : activate(plastic, 10)
	}
}

*/


